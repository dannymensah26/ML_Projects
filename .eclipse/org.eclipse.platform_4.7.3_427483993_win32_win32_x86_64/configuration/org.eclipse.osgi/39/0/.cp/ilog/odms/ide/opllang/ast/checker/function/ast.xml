<?xml version="1.0" encoding="UTF-8"?>
<ast>
  <classes>
    <class name="IloObject">
      <methods>
        <method isConstructor="true" name="IloObject"  type="IloObject"  javaDoc="/**
 *  
 * @class
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloConstraint">
      <methods>
        <method isConstructor="true" name="IloConstraint"  type="IloConstraint"  javaDoc="/**
 * @class
 *
 * @note {Caution}
 * For technical reasons, the lower and upper bound properties LB and UB are currently
 * accessible only during postprocessing and flow control in constraints assigned in a
 * &lt;code class=&quot;code&quot;&gt;forall&lt;/code&gt; declaration.
 * The &lt;code class=&quot;code&quot;&gt;undefined&lt;/code&gt; value is returned instead.
 * You can nevertheless modify the bounds.
 *
 * @example
 * dvar float x in 5..20;
 * dvar float y in 0..20;
 *
 * maximize x+y;
 *
 * subject to
 * {
 *  ct1:2*x+y&lt;=10;
 *  ct2:x&lt;=7;  
 * }
 *  
 * execute
 * {
 *  writeln( ct1.name,&quot; &quot;,ct1.UB,&quot; &quot;,ct1.LB,&quot; &quot;,ct1.dual,&quot; &quot;,ct1.slack); 
 *  writeln( ct2.name,&quot; &quot;,ct2.UB,&quot; &quot;,ct2.LB,&quot; &quot;,ct2.dual,&quot; &quot;,ct2.slack); 
 * }
 *
 * @example {After execution&#44; the Scripting log shows:}
 * ct1 10 -Infinity 1 0
 * ct2 7 -Infinity 0 2
 * 
 * @opl-type constraint
 * @ilog.undocumented.constructor 
 * @ilog.undocumented.jsFile
 * @iterating Default behavior.
 * @named Default behavior.
 */" />
        <method name="name" isProperty="true"  type="string"  javaDoc="/**
 * &lt;p&gt;Name of the constraint.&lt;/p&gt;
 *
 * @type string
 * @available postprocessing
 * @available flow control
 */" />
        <method name="dual" isProperty="true"  type="float"  javaDoc="/**
 * &lt;p&gt;Dual value in a solution. Exists only for linear problems with CPLEX.&lt;/p&gt;
 *
 * @available postprocessing
 * @available flow control
 * @type float
 */" />
        <method name="slack" isProperty="true"  type="float"  javaDoc="/**
 * &lt;p&gt;Slack value in a solution.&lt;/p&gt; 
 *
 * &lt;p&gt;Exists only for CPLEX linear mixed integer problems.&lt;/p&gt;
 *
 * @available postprocessing
 * @available flow control
 * @type float
 */" />
        <method name="LB" isProperty="true"  type="float"  javaDoc="/**
 * &lt;p&gt;Lower bound.&lt;/p&gt;
 *
 * @available postprocessing
 * @available flow control (write only)
 * @type float
 */" />
        <method name="UB" isProperty="true"  type="float"  javaDoc="/**
 * &lt;p&gt;Upper bound.&lt;/p&gt;
 *
 * @available postprocessing
 * @available flow control (write only)
 * @type float
 */" />
        <method name="setCoef" argument1="dvar float" argument2="float"  javaDoc="/**
 * &lt;p&gt;Changes the coefficient of a decision variable in the invoking constraint.
 * This method is limited to constraints that use simple real linear expressions with no
 * aggregation. In other cases, use the method from the &lt;code&gt;IloCplex&lt;/code&gt; class.&lt;/p&gt;
 *
 * @param dvar Decision variable.
 * @param coef The new linear coefficient.
 * @available all
 *
 * @see IloCplex
 */" />
        <method name="setBounds" argument1="float" argument2="float"  javaDoc="/**
 * &lt;p&gt;Sets &lt;code&gt;lb&lt;/code&gt; as the lower bound and
 * &lt;code&gt;ub&lt;/code&gt; as the upper bound of the invoking numeric variable.&lt;/p&gt;
 *
 * &lt;note&gt;The member function&lt;code&gt;setBounds&lt;/code&gt; notifies Concert Technology
 * algorithms about the change of bounds in the numeric variable.&lt;/note&gt;
 *
 * @param lb Lower bound.
 * @param ub Upper bound.
 * @available all
 *
 * @see IloCplex
 */" />
      </methods>
    </class>
    <class name="IloIntRange">
      <methods>
        <method isConstructor="true" name="IloIntRange"  type="IloIntRange"  javaDoc="/**
 * @class
 *
 * &lt;table class=&quot;NoteTable&quot;&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;span class=&quot;NoteTitle&quot;&gt;Note&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td class=&quot;Note&quot;&gt;
 * &lt;code&gt;IloIntRange&lt;/code&gt; cannot be used for a range of floats.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * 
 * @example
 *  range r=1..10;
 *
 *  execute {
 *    writeln(r.LB);
 *    writeln(r.UB);
 *  }
 *
 * @example {Output:}
 * 1
 * 10
 *
 * @iterating Iterates on the integer numbers in this range, starting with the lower bound and ending at the upper bound.
 * @named Default behavior.
 * @opl-type range
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 */" />
        <method name="LB" isProperty="true"  type="float"  javaDoc="/**
 * Lower bound.
 * @type float
 * @available all
 */" />
        <method name="UB" isProperty="true"  type="float"  javaDoc="/**
 * Upper bound.
 * @type float
 * @available all
 */" />
        <method name="size" isProperty="true"  type="int"  javaDoc="/**
 * The width of this collection.
 * @available all
 */" />
      </methods>
    </class>
    <class name="IloMap">
      <methods>
        <method isConstructor="true" name="IloMap"  type="IloMap"  javaDoc="/**
 * @class
 *
 * @example
 * int a[i in 1..5]=i;
 *
 * dvar int x[2..6];
 *
 * subject to
 * {
 *  forall(i in 2..6) ct:x[i]==a[i-1];
 * } 
 * 
 * execute {
 *   writeln(a);
 *   a[2]=10;
 *   writeln(a);
 *   for(var i in a) write(i);
 *   writeln();
 *   writeln(&quot;constraint&quot;);
 *   for(i in ct) write(i);
 *   writeln(); 
 * }
 * 
 * @example {Output:}
 * [1 2 3 4 5]
 * [1 10 3 4 5]
 * 12345
 * constraint
 * 23456 
 *
 * @iterating Iterates on the items of its indexer.
 * @named Returns the item with the given index. For multidimensional arrays, the returned item is itself an array.
 * @opl-type int A[]
 * @opl-type float A[]
 * @opl-type string A[]
 * @opl-type T A[], where T is a declared tuple type
 * @opl-type {int} A[]
 * @opl-type {float} A[]
 * @opl-type {string} A[]
 * @opl-type {T} A[], where T is a declared tuple type
 * @opl-type dvar int A[]
 * @opl-type dvar int+ A[]
 * @opl-type dvar float A[]
 * @opl-type dvar float+ A[]
 * @opl-type dvar boolean A[]
 * @opl-type constraint A[]
 * @opl-type And corresponding multidimensional arrays, having items of array type.
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available all
 */" />
        <method name="indexer" isProperty="true"  type="IloDiscreteDataCollection"  javaDoc="/**
 * Gets the indexer collection of the array.
 * If the array is multidimensional, &lt;code&gt;indexer&lt;/code&gt;  
 * returns only the first dimension part.
 *
 * @type IloDiscreteDataCollection
 * @available all
 */" />
        <method name="solutionValue" isProperty="true"  type="IloMap"  javaDoc="/**
 * For an array of decision variables, returns the array of values in the current solution.
 * 
 * @type IloMap
 * @available postprocessing
 */" />
        <method name="size" isProperty="true"  type="int"  javaDoc="/**
 * Gets the size of the array, which is the size of its indexer collection.
 * If the array is multidimensional, &lt;code&gt;size&lt;/code&gt; 
 * returns only the first dimension part.
 *
 * @type int
 * @available all
 */" />
      </methods>
    </class>
    <class name="IloMap_sub">
      <methods>
        <method isConstructor="true" name="IloMap_sub"  type="IloMap_sub"  javaDoc="/**
 * @ignore
 *
 * Implementation detail.
 */" />
        <method name="indexer" isProperty="true"  type="IloDiscreteDataCollection"  javaDoc="/**
 * @ignore
 *
 * Implementation detail.
 */" />
        <method name="solutionValue" isProperty="true"  type="float"  javaDoc="/**
 * @ignore
 * Implementation detail.
 */" />
        <method name="size" isProperty="true"  type="int"  javaDoc="/**
 * @ignore
 *
 * Implementation detail.
 */" />
      </methods>
    </class>
    <class name="IloNumExpr">
      <methods>
        <method isConstructor="true" name="IloNumExpr"  type="IloNumExpr"  javaDoc="/**
 * @class
 *
 * &lt;p&gt;Using an &lt;code&gt;IloNumExpr&lt;/code&gt; object 
 * implicitly provides access to its &lt;code&gt;solutionValue&lt;/code&gt; property.
 *The postprocessing expression&lt;/p&gt;
 * &lt;pre class=&quot;ShortCode&quot;&gt;
 *   x*100
 * &lt;/pre&gt;
 * is equivalent to
 * &lt;pre class=&quot;ShortCode&quot;&gt;
 *   x.solutionValue * 100
 * &lt;/pre&gt;
 * where &lt;code&gt;x&lt;/code&gt; has been declared as
 * &lt;pre class=&quot;ShortCode&quot;&gt;
 *   dvar float x0;
 *   dexpr float x = x0+1;
 * &lt;/pre&gt;
 * in the modeling part.
 * &lt;p&gt;
 * @example
 * dvar float x0 in 0..20;
 *  dexpr float x = x0+1;
 * 
 * maximize x;
 *  
 * subject to {
 *  }
 * 
 * execute {
 *    writeln(x.name);
 *    writeln(x.solutionValue);
 *  }
 * 
 * @example {After execution&#44; the Scripting log shows:}
 * x
 * 21
 *
 * @iterating Default behavior.
 * @named Default behavior.
 * 
 * @opl-type dexpr int
 * @opl-type dexpr float
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 */" />
        <method name="name" isProperty="true"  type="string"  javaDoc="/**
 * The name of the decision expression.
 * @type string
 * @available all (read only)
 * @available preprocessing (write)
 */" />
        <method name="solutionValue" isProperty="true"  type="float"  javaDoc="/**
 * Values of the decision expression in the current solution.
 * Note that using an &lt;code&gt;IloNumExpr&lt;/code&gt; object 
 * implicitly provides access to its &lt;code&gt;solutionValue&lt;/code&gt; property.
 * @type float
 * @available postprocessing
 */" />
      </methods>
    </class>
    <class name="IloNumVar">
      <methods>
        <method isConstructor="true" name="IloNumVar"  type="IloNumVar"  javaDoc="/**
 * @class
 *
 * &lt;p&gt;Using an &lt;code&gt;IloNumVar&lt;/code&gt; object 
 * implicitly provides access to its &lt;code&gt;solutionValue&lt;/code&gt; property.
 *The postprocessing expression&lt;/p&gt;
 * &lt;pre class=&quot;ShortCode&quot;&gt;
 *   x*100
 * &lt;/pre&gt;
 * is equivalent to
 * &lt;pre class=&quot;ShortCode&quot;&gt;
 *   x.solutionValue * 100
 * &lt;/pre&gt;
 * where &lt;code&gt;x&lt;/code&gt; has been declared as
 * &lt;pre class=&quot;ShortCode&quot;&gt;
 *   dvar float x;
 * &lt;/pre&gt;
 * in the modeling part.
 * 
 * @example
 * dvar float x in 0..20;
 *
 * maximize x;
 * 
 * subject to {
 * }
 *
 * execute {
 *   writeln(x.name);  
 *   writeln(x.LB,&quot; &quot;,x.UB,&quot; &quot;,x.solutionValue);
 *   writeln(x.reducedCost);
 * }
 * 
 * @example {After execution&#44; the Scripting log shows:}
  * x
 * 0 20 20
 * 1
 *
 * @iterating Default behavior.
 * @named Default behavior.
 *
 * @opl-type dvar int
 * @opl-type dvar int+
 * @opl-type dvar float
 * @opl-type dvar float+
 * @opl-type dvar boolean
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 * @extends IloNumExpr
 */" />
        <method name="LB" isProperty="true"  type="float"  javaDoc="/**
 * Accesses the lower bound set for the decision variable.
 * @type float
 * @available all
 * @available preprocessing (write)
 */" />
        <method name="UB" isProperty="true"  type="float"  javaDoc="/**
 * Accesses the upper bound set for the decision variable.
 * @type float
 * @available all
 * @available preprocessing (write)
 */" />
        <method name="direction" isProperty="true"  type="string"  javaDoc="/**
 * Branching direction for the decision variable (CPLEX models only).
 *One of &lt;code&gt;&quot;BranchDown&quot;, &quot;BranchGlobal&quot;, &quot;BranchUp&quot;&lt;/code&gt;.
 * @type string
 * @available all (read only)
 * @available preprocessing (write)
 */" />
        <method name="reducedCost" isProperty="true"  type="float"  javaDoc="/**
 * The reduced cost for the decision variable (CPLEX models only).
 * @type float
 * @available postprocessing
 */" />
        <method name="priority" isProperty="true"  type="float"  javaDoc="/**
 * Accesses the priority level of the decision variable (CPLEX models only).
 * @type float
 * @available all (read only)
 * @available preprocessing (write)
 */" />
        <method name="name" isProperty="true"  type="string"  javaDoc="/**
 * &lt;p&gt;Name of the constraint.&lt;/p&gt;
 *
 * @type string
 * @available postprocessing
 * @available flow control
 */" />
        <method name="solutionValue" isProperty="true"  type="float"  javaDoc="/**
 * Value in the current solution for the objective.
 * @type float
 * @available postprocessing
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloOplCplexBasis">
      <methods>
        <method isConstructor="true" name="IloOplCplexBasis"  type="IloOplCplexBasis"  javaDoc="/**
 * @class
 * This is an OPL service class provided to support the CPLEX warm start functionality
 * for linear programming models.
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 * &lt;p&gt;See the CPLEX documentation for the methods
 * &lt;code&gt;IloCplex::getBasisStatuses&lt;/code&gt; and &lt;code&gt;IloCplex::setBasisStatuses&lt;/code&gt;,
 * or for &lt;code&gt;CPXgetbasis&lt;/code&gt; and &lt;code&gt;CPXcopybasis&lt;/code&gt; for details.
 * &lt;/p&gt;
 *
 * @example
 * float maxOfx = ...;
 * dvar float x;
 *
 * maximize x;
 * subject to {
 *   x&lt;=maxOfx;
 * } 
 *
 * @example {and the following data:}
 * maxOfx=10;
 * 
 * @example {Flow control script:}
 * main {   
 *   var basis= new IloOplCplexBasis();
 *   var source = new IloOplModelSource(&quot;basicmodel.mod&quot;);
 *   var cplex = new IloCplex();
 *   var def = new IloOplModelDefinition(source);
 *   var opl = new IloOplModel(def,cplex);
 *   var data = new IloOplDataSource(&quot;basicmodel.dat&quot;);
 *
 *   opl.addDataSource(data);
 *   opl.generate();
 *   if (cplex.solve()) {
 *      writeln(&quot;OBJ = &quot; + cplex.getObjValue());
 *   }
 *   else {
 *      writeln(&quot;No solution&quot;);
 *   }
 *
 *   if ( !basis.getBasis(cplex) ) {
 *      writeln(&quot;warm start preparation failed: &quot;,basis.status);
 *   } else {
 *      writeln(&quot;warm start preparation succeeded &quot;);
 *   }
 *   var opl2 = new IloOplModel(def,cplex);
 *   var data2= new IloOplDataElements();
 *   data2.maxOfx=11;
 *   opl2.addDataSource(data2);
 *   opl2.generate();
 *
 *   if ( !basis.setBasis(cplex) ) {
 *      writeln(&quot;warm start &quot;,basis.Nrows,&quot;x&quot;,basis.Ncols,&quot; failed: &quot;,basis.status);
 *   } else {
 *      writeln(&quot;warm start &quot;,basis.Nrows,&quot;x&quot;,basis.Ncols,&quot; succeeded &quot;);
 *   }
 *
 *   if (cplex.solve()) {
 *      writeln(&quot;OBJ = &quot; + cplex.getObjValue());
 *   } else {
 *      writeln(&quot;No solution&quot;);
 *   }
 *
 *   opl.end();
 *   opl2.end();
 *   data.end(); 
 *   def.end(); 
 *   cplex.end(); 
 *   basis.end();
 *   source.end(); 
 * }
 * 
 * @example {After execution the Scripting log shows:}
 *  OBJ = 10
 *  warm start preparation succeeded
 *  warm start 1x2 succeeded
 *  OBJ = 11
 *
 * @iterating Default behavior.
 * @named Default behavior.
 *
 * @available flow control
 * @ilog.undocumented.jsFile
 * @extends IloObject
 */" />
        <method name="Nrows" isProperty="true"  type="int"  javaDoc="/**
 * Accesses the number of rows in the currently stored basis.
 *
 * @type int
 * @available flow control
 */" />
        <method name="Ncols" isProperty="true"  type="int"  javaDoc="/**
 * Accesses the number of columns in the currently stored basis.
 *
 * @type int
 * @available flow control
 */" />
        <method name="setBasis" argument1="IloCplex"  javaDoc="/**
 * Restores the basis information available from the given CPLEX instance.
 * This utility can restore bases only if the problem of the given CPLEX instance 
 * has exactly the same number of rows and columns as the problem it was taken from. 
 *
 * @available flow control
 * @param cplex Restores this basis information on the given CPLEX instance.
 * @return &lt;code&gt;true&lt;/code&gt; if successful. The CPLEX return status is available as the property &lt;code&gt;status&lt;/code&gt;.
 */" />
        <method name="getBasis"  type="boolean" argument1="IloCplex"  javaDoc="/**
 * Accesses this basis information from the given CPLEX instance.
 *
 * @available flow control
 * @type boolean
 * @param cplex Sets the basis information to this instance of CPLEX.
 * @return &lt;code&gt;true&lt;/code&gt; if successful. The CPLEX return status is available as the property &lt;code&gt;status&lt;/code&gt;.
 */" />
        <method name="attach" argument1="arrayof_dvar float" argument2="arrayof_IloBool"  javaDoc="/**
 * Attaches a variable array to a status array.
 * Once attachments exist, only the elements with attachments
 * are taken into account to get/set the basis.
 *
 * @available flow control
 * @param dvars The array of variables to consider.
 * @param statuses The array of values to get/set basis statuses.
 */" />
        <method name="status" isProperty="true"  type="int"  javaDoc="/**
 * CPLEX status of last call.
 *
 * @type int
 * @available flow control
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloOplCplexVectors">
      <methods>
        <method isConstructor="true" name="IloOplCplexVectors"  type="IloOplCplexVectors"  javaDoc="/**
 * @class
 * This is an OPL service class provided to support the CPLEX warm start functionality
 * for mixed integer programming models.
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 * &lt;p&gt;See the CPLEX documentation for the methods 
 * &lt;code&gt;IloCplex::getStart&lt;/code&gt; and &lt;code&gt;IloCplex::setStart&lt;/code&gt; or for
 * &lt;code&gt;CPXgetmipstart&lt;/code&gt;, &lt;code&gt;CPXcopymipstart&lt;/code&gt; for details.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * @example { For the following basic model: }
 * int maxOfx = ...;
 * dvar int x;
 *
 * maximize x;
 * subject to {
 *   x&lt;=maxOfx; 
 *   }
 *
 * @example {and the following data:}
 * maxOfx=10;
 *
 * @example { Flow control script:}
 * main {   
 *   var vectors= new IloOplCplexVectors();
 *   var source = new IloOplModelSource(&quot;basicmodel2.mod&quot;);
 *   var cplex = new IloCplex();
 *   var def = new IloOplModelDefinition(source);
 *   var opl = new IloOplModel(def,cplex);
 *   var data = new IloOplDataSource(&quot;basicmodel.dat&quot;);
 *   opl.addDataSource(data);
 *   opl.generate();
 *   if (cplex.solve()) {
 *      writeln(&quot;OBJ = &quot; + cplex.getObjValue());
 *   } else {
 *      writeln(&quot;No solution&quot;);
 *   }
 *   if ( !vectors.getStart(cplex) ) {
 *      writeln(&quot;warm start preparation failed: &quot;,vectors.status);
 *   } else {
 *      writeln(&quot;warm start preparation successful &quot;);
 *   }
 *   var opl2 = new IloOplModel(def,cplex);
 *   var data2= new IloOplDataElements();
 *   data2.maxOfx=11;
 *   opl2.addDataSource(data2);
 *   opl2.generate();
 *   if ( !vectors.setStart(cplex) ) {
 *      writeln(&quot;warm start &quot;,vectors.Nrows,&quot;x&quot;,vectors.Ncols,&quot; failed: &quot;,vectors.status);
 *   } else {
 *      writeln(&quot;warm start &quot;,vectors.Nrows,&quot;x&quot;,vectors.Ncols,&quot; succeeded &quot;);
 *   }
 *   if (cplex.solve()) {
 *      writeln(&quot;OBJ = &quot; + cplex.getObjValue());
 *   } else {
 *      writeln(&quot;No solution&quot;);
 *   }
 *   opl.end();
 *   opl2.end();
 *   data.end(); 
 *   def.end(); 
 *   cplex.end(); 
 *   vectors.end();
 *   source.end(); 
 * }
 * 
 * @example {After execution the Scripting  log shows:}
 *  OBJ = 10
 *  warm start preparation succeeded
 *  warm start 1x2 succeeded
 *  OBJ = 11
 *
 * @iterating Default behavior.
 * @named Default behavior.
 * @available flow control
 * @ilog.undocumented.jsFile
 * @extends IloObject
 */" />
        <method name="Nrows" isProperty="true"  type="int"  javaDoc="/**
 * Accesses the number of rows in the CPLEX matrix from which the vectors have been taken.
 *  OPL uses this information when restoring the warm start information.
 *
 * @type int
 * @available flow control
 */" />
        <method name="Ncols" isProperty="true"  type="int"  javaDoc="/**
 * Accesses the number of columns in the CPLEX matrix
 * from which the warm start information has been taken.
 *  OPL uses this information when restoring the warm start information.
 *
 * @type int
 * @available flow control
 */" />
        <method name="attach" argument1="arrayof_dvar float" argument2="arrayof_float"  javaDoc="/**
 * Attaches a variable array to a value array.
 * Once attachments exist, only the elements with attachments
 * are taken into account to get/set the basis.
 *
 * @available flow control
 * @param dvars The array of variables to consider.
 * @param values The array of values to get/set.
 */" />
        <method name="setStart" argument1="IloCplex"  javaDoc="/**
* Restores the MIP start information available for the given CPLEX instance.
* This utility can restore MIP start only if the problem of the given CPLEX instance has exactly 
* the same number of rows and columns as the problem it was taken from.
* @available flow control
* @param cplex Restores the MIP start information available for this instance of CPLEX.
* @return &lt;code&gt;true&lt;/code&gt; if successful. The CPLEX return status is available as the property &lt;code&gt;status&lt;/code&gt;.
*/" />
        <method name="getStart"  type="boolean" argument1="IloCplex"  javaDoc="/**
* Saves the MIP start information for the given CPLEX instance.
*
* @available flow control
* @type boolean
* @param cplex Saves the MIP start information for this instance of CPLEX.
* @return &lt;code&gt;true&lt;/code&gt; if successful. The CPLEX return status is available as the property &lt;code&gt;status&lt;/code&gt;.
*/" />
        <method name="deleteStart"  type="void" argument1="IloCplex"  javaDoc="/**
* Deletes the MIP start information for the given CPLEX instance.
*
* @available flow control
* @type void
* @param cplex Saves the MIP start information for this instance of CPLEX.
*/" />
        <method name="clear"  type="void"  javaDoc="/**
* Clears the vector from either all the previous attach commands or the getStart call.
*
* @available flow control
* @type void
*/" />
        <method name="status" isProperty="true"  type="int"  javaDoc="/**
 * The CPLEX status of the last call.
 *
 * @type int
 * @available flow control
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloOplRelaxationIterator">
      <methods>
        <method isConstructor="true" name="IloOplRelaxationIterator"  type="IloOplRelaxationIterator"  javaDoc="/**
 * @class 
 *This is an OPL service class provided to support the CPLEX relaxation functionality.
 *
 * @example 
 * An example of relaxing a conflict is provided with your installation. See
 * &lt;Install_dir&gt;\opl\examples\opl\relaxationIterator\relaxationIterator.mod
 *
 * @iterating Default behavior.
 * @named Default behavior.
 * @available flow control and preprocessing
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 * @extends IloObject
 */" />
        <method name="LB" isProperty="true"  type="float"  javaDoc="/**
 * Provides access to the LB property of the current relaxation.
 * @available flow control (read only)
 * @type float
 */" />
        <method name="UB" isProperty="true"  type="float"  javaDoc="/**
 * Provides access to the UB property of the current relaxation.
 * @available flow control (read only)
 * @type float
 */" />
        <method name="ct" isProperty="true"  type="IloConstraint"  javaDoc="/**
 * Provides access to the relaxed &lt;code&gt;IloConstraint&lt;/code&gt; of the current relaxation.
 * @available flow control (read only)
 * @type IloConstraint
 */" />
        <method name="attach" argument2="arrayof_float" argument1="arrayof_constraint"  javaDoc="/**
* Attaches a constraint array to a preference array.
* Once attachments exist, only the elements with attachments
* are taken into account for relaxations.
*
* @available flow control
* @param {constraints|array of constraints} ct  
* @param {preference|array of preferences} pref 
*/" />
        <method name="printRelaxation"  type="string"  javaDoc="/**
 * Prints the relaxations proposed to obtain a feasible model.
 *
 * @available flow control
 * @type string
 * @return A string containing the relaxations proposed to obtain a feasible model and changes the state of the invoking object to relaxation mode.
 */" />
        <method name="relaxedUB" isProperty="true"  type="float"  javaDoc="/**
 * Provides access to the relaxed UB property of the current relaxation.
 * @available flow control (read only)
 * @type float
 */" />
        <method name="relaxedLB" isProperty="true"  type="float"  javaDoc="/**
 * Provides access to the relaxed LB property of the current relaxation.
 * @available flow control (read only)
 * @type float
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloOplConflictIterator">
      <methods>
        <method isConstructor="true" name="IloOplConflictIterator"  type="IloOplConflictIterator"  javaDoc="/**
 * @class
 * This is an OPL service class provided to support the CPLEX conflict refinement functionality.
 *
 * @example
 * An example of refining a conflict is provided with your installation. See:
 * &lt;Install_dir&gt;\opl\examples\opl\conflictIterator\conflictIterator.mod
 *
 * @iterating Default behavior.
 * @named Default behavior.
 * @available flow control and preprocessing
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 * @extends IloObject
 */" />
        <method name="ct" isProperty="true"  type="IloConstraint"  javaDoc="/**
 * Provides access to the conflicting &lt;code&gt;IloConstraint&lt;/code&gt; if it is a constraint.
 * @available flow control (read only)
 * @type IloConstraint
 */" />
        <method name="attach" argument2="arrayof_float" argument1="arrayof_constraint"  javaDoc="/**
 * Attaches a constraint array to a preference array.
 * Once attachments exist, only the elements with attachments
 * are taken into account for conflict refinement.
 *
 * @available flow control
 * @param cts The array of constraints.
 * @param prefs The array of preferences.
 */" />
        <method name="printConflict"  type="string"  javaDoc="/**
 * Prints the conflicting constraints found in an infeasible model.
 *
 * @available flow control
 * @type string
 * @return The string containing the conflicting constraints in an infeasible model.
 */" />
        <method name="clearAttachments"  javaDoc="/**
 * Clears previously attached constraints.
 *
 * @available flow control
 */" />
        <method name="excludeConflict"  javaDoc="/**
 * Excludes the current conflict and finds the next one.
 *
 * &lt;p&gt;Allows iteration over more conflicts.
 * The currently conflicting constraints will be excluded from the next conflict refinement.
 * &lt;/p&gt;
 *
 * @available flow control
 */" />
        <method name="status" isProperty="true"  type="string"  javaDoc="/**
 * Provides access to the conflict status property of the current conflict, either 
 * &lt;code&gt;ConflictPossibleMember&lt;/code&gt; or &lt;code&gt;ConflictMember&lt;/code&gt;.
 * @available flow control (read only)
 * @type string
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloOplDataSource">
      <methods>
        <method isConstructor="true" name="IloOplDataSource"  type="IloOplDataSource" argument1="string"  javaDoc="/**
 * @class
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 *
 * @example {For the following basic model:}
 * float maxOfx = ...;
 * dvar float x;
 *
 * maximize x;
 * subject to {
 *   x&lt;=maxOfx;
 * } 
 *
 * @example {and the following data:}
 *   maxOfx=10;
 * 
 * @example { Flow control script:}
 * main { 
 *   var source = new IloOplModelSource(&quot;basicmodel.mod&quot;);
 *   var cplex = new IloCplex();
 *   var def = new IloOplModelDefinition(source);
 *   var opl = new IloOplModel(def,cplex);
 *   var data = new IloOplDataSource(&quot;basicmodel.dat&quot;);
 *   opl.addDataSource(data);
 *   opl.generate();
 *   if (cplex.solve()) {
 *      writeln(&quot;OBJ = &quot; + cplex.getObjValue());
 *   }  else {
 *      writeln(&quot;No solution&quot;);
 *   }
 *   var opl2 = new IloOplModel(def,cplex);
 *   var data2= new IloOplDataElements();
 *   data2.maxOfx=11;
 *   opl2.addDataSource(data2);
 *   opl2.generate();
 *
 *   if (cplex.solve()) {
 *      writeln(&quot;OBJ = &quot; + cplex.getObjValue());
 *   } else {
 *      writeln(&quot;No solution&quot;);
 *   }
 *
 *   opl.end();
 *   opl2.end();
 *   data.end(); 
 *   def.end(); 
 *   cplex.end(); 
 *   source.end(); 
 * }
 *
 * @example {After execution the Scripting log shows:}
 *  OBJ = 10
 *  OBJ = 11
 *
 * @iterating Default behavior.
 * @named Default behavior.
 * @available flow control
 * @param path The path to the &lt;code&gt;.dat&lt;/code&gt; file.
 * @ilog.undocumented.jsFile
 * @extends IloObject
 */" />
        <method name="name" isProperty="true"  type="string"  javaDoc="/**
 * Accesses the name of the data source.
 * &lt;p&gt;This is the path for file model sources.&lt;/p&gt;
 * &lt;p&gt;A data source cannot be reused for multiple models.&lt;/p&gt;
 * @type string
 * @available flow control
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloOplDataElements">
      <methods>
        <method isConstructor="true" name="IloOplDataElements"  type="IloOplDataElements"  javaDoc="/**
 * @class
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 *
 * @example {For the following basic model:}
 * float maxOfx = ...;
 * dvar float x;
 *
 * maximize x;
 * subject to {
 *   x&lt;=maxOfx;
 * } 
 *
 * @example {and the following data:}
 * maxOfx=10;
 *
 * @example {Flow control script:}
 * main { 
 *   var source = new IloOplModelSource(&quot;basicmodel.mod&quot;);
 *   var cplex = new IloCplex();
 *   var def = new IloOplModelDefinition(source);
 *   var opl = new IloOplModel(def,cplex);
 *   var data = new IloOplDataSource(&quot;basicmodel.dat&quot;);
 *   opl.addDataSource(data);
 *   opl.generate();
 *   if (cplex.solve()) {
 *      writeln(&quot;OBJ = &quot; + cplex.getObjValue());
 *
 *   } else {
 *      writeln(&quot;No solution&quot;);
 *   }
 *   var opl2 = new IloOplModel(def,cplex);
 *   var data2= new IloOplDataElements();
 *   data2.maxOfx=11;
 *   opl2.addDataSource(data2);
 *   opl2.generate();
 *
 *   if (cplex.solve()) {
 *      writeln(&quot;OBJ = &quot; + cplex.getObjValue());
 *   } else {
 *      writeln(&quot;No solution&quot;);
 *   }
 *
 *   opl.end();
 *   opl2.end();
 *   data.end(); 
 *   def.end(); 
 *   cplex.end(); 
 *   source.end(); 
 * }
 * 
 * @example {After execution&#44; the Scripting log shows:}
 *  OBJ = 10
 *  OBJ = 11
 *
 * @iterating Iterates on the OPL data elements available in this data source.
 * @named Default behavior. 
 * @available flow control
 * @ilog.undocumented.jsFile
 * @extends IloOplDataSource
 */" />
        <method name="_element_name_" isProperty="true"  type="string"  javaDoc="/**
 * The OPL data element by its name.
 *
 * @available flow control
 * @type string
 */" />
        <method name="_new_name_" isProperty="true"  type="string"  javaDoc="/**
 * Adds a new element with the given name and value.
 *
 * @available flow control
 * @type string
 */" />
        <method name="name" isProperty="true"  type="string"  javaDoc="/**
 * &lt;p&gt;Name of the constraint.&lt;/p&gt;
 *
 * @type string
 * @available postprocessing
 * @available flow control
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloOplInputFile">
      <methods>
        <method isConstructor="true" name="IloOplInputFile"  type="IloOplInputFile" argument1="string"  javaDoc="/**
 * @class
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 *
 * @example
 * execute {
 *    var f = new IloOplInputFile(&quot;output.txt&quot;);
 *    if (f.exists) {
 *      writeln(&quot;the file output.txt exists&quot;);
 *      var s;
 *      while (!f.eof) {
 *       s=f.readline();
 *       writeln(s);
 *      }
 *      f.close();
 *    } else { 
 *      writeln(&quot;the file output.txt doesn&apos;t exist&quot;);
 *    }
 * }
 * 
 * @example { 
 * If the file &lt;code&gt;output.txt&lt;/code&gt; has previously been created 
 * (for the file&apos;s content see the example in &lt;code&gt;IloOplOutputFile&lt;/code&gt;)}
 * the file output.txt exists
 * Hello World
 * another line
 *
 * @iterating Empty iteration.
 * @named Default behavior.  
 * @ilog.undocumented.jsFile
 * @available flow control
 * @param path &lt;em&gt;Optional:&lt;/em&gt; The path of the file to open.
 */" />
        <method name="exists" isProperty="true"  type="boolean"  javaDoc="/**
 * Returns &lt;code&gt;true&lt;/code&gt; if the file exists.
 * @type boolean
 * @available flow control
 */" />
        <method name="open" argument1="string"  javaDoc="/**
 * Opens the file on the given path. 
 * &lt;p&gt;Raises an error if the file does not exist.&lt;/p&gt;
 *
 * @available flow control
 * @param path The path of the file to open.
 * @deprecated The file is automatically opened when needed.
 */" />
        <method name="isOpen" isProperty="true"  type="boolean"  javaDoc="/**
 * Returns &lt;code&gt;true&lt;/code&gt; if the file is currently open.
 * @type boolean
 * @available flow control
 * @deprecated replaced by exists
 */" />
        <method name="eof" isProperty="true"  type="boolean"  javaDoc="/**
 * Returns &lt;code&gt;true&lt;/code&gt; if the file has been entirely read and is at end of file (eof).
 * @type boolean
 * @available flow control
 */" />
        <method name="close"  javaDoc="/**
 * Closes the input file.
 *
 * @available flow control
 */" />
        <method name="readline"  type="string"  javaDoc="/**
 * Reads one line from the input file.
 *
 * @type string
 * @available flow control
 * @return The line read.
 */" />
      </methods>
    </class>
    <class name="IloOplModel">
      <methods>
        <method isConstructor="true" name="IloOplModel"  type="IloOplModel" argument1="IloOplModelDefinition" argument2="undefined"  javaDoc="/**
 * Uses the model definition &lt;code&gt;def&lt;/code&gt; and the engine &lt;code&gt;CPLEX&lt;/code&gt; or &lt;code&gt;CP&lt;/code&gt;. 
 * If the engine parameter is missing &lt;code&gt;thisOplModel.cplex&lt;/code&gt; or &lt;code&gt;thisOplModel.cp&lt;/code&gt; will be used.
 *
 * @param def Uses this model definition.
 * @param engine Uses this engine, CPLEX or CP. Optional, if missing &lt;code&gt;thisOplModel.cplex&lt;/code&gt; or &lt;code&gt;thisOplModel.cp&lt;/code&gt;  will be used.  
 * @available flow control
 *
 * @class
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 *
 * @iterating Iterates on the OPL elements declared before the current &lt;code&gt;execute&lt;/code&gt; or &lt;code&gt;main&lt;/code&gt; block.
 * @named Default behavior. 
 * 
 * @example {For the following basic model:}
 * float maxOfx = ...;
 * dvar float x;
 *
 * maximize x;
 * subject to {
 *   x&lt;=maxOfx; 
 * }
 *
 * @example {and the following data:}
 *   maxOfx=10;
 * 
 * @example {Flow control script:}
 * main { 
 *   var source = new IloOplModelSource(&quot;basicmodel.mod&quot;);
 *   var cplex = new IloCplex();
 *   var def = new IloOplModelDefinition(source);
 *   var opl = new IloOplModel(def,cplex);
 *   var data = new IloOplDataSource(&quot;basicmodel.dat&quot;);
 *   opl.addDataSource(data);
 *   opl.generate();
 *   if (cplex.solve()) {
 *      writeln(&quot;OBJ = &quot; + cplex.getObjValue());
 *   } else {
 *      writeln(&quot;No solution&quot;);
 *   }
 *   var opl2 = new IloOplModel(def,cplex);
 *   var data2= new IloOplDataElements();
 *   data2.maxOfx=11;
 *   opl2.addDataSource(data2);
 *   opl2.generate();
 *
 *   if (cplex.solve()) {
 *      writeln(&quot;OBJ = &quot; + cplex.getObjValue());
 *   } else {
 *      writeln(&quot;No solution&quot;);
 *   }
 *
 *   opl.end();
 *   opl2.end();
 *   data.end(); 
 *   def.end(); 
 *   cplex.end(); 
 *   source.end(); 
 * }
 *
 * @ilog.undocumented.jsFile
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Clears the memory used by this model.
 * @available flow control
 */" />
        <method name="printRelaxation"  type="string"  javaDoc="/**
 * Prints the relaxations proposed to obtain a feasible model.
 *
 * @available flow control
 * @type string
 * @return A string containing the relaxations proposed to obtain a feasible model and changes the state of the invoking object to relaxation mode.
 */" />
        <method name="printConflict"  type="string"  javaDoc="/**
 * Prints the conflicting constraints found in an infeasible model.
 *
 * @available flow control
 * @type string
 * @return The string containing the conflicting constraints found in an infeasible model.
 */" />
        <method name="_element_name_" isProperty="true"  type="string"  javaDoc="/**
 * An OPL element by its name.
 * &lt;p&gt;Only elements of scalar type can be modified in flow control.&lt;/p&gt;
 * @available all (read only)
 * @type string
 */" />
        <method name="modelDefinition" isProperty="true"  type="IloOplModelDefinition"  javaDoc="/**
 * The model definition for this OPL model.
 * &lt;p&gt;The model definition can be used to create more instances of
 * &lt;code&gt;IloOplModel&lt;/code&gt; for the same &lt;code&gt;.mod&lt;/code&gt; file.
 * A data source cannot be reused for multiple models.&lt;/p&gt;
 *
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 *
 * @type IloOplModelDefinition
 * @available flow control
 */" />
        <method name="dataElements" isProperty="true"  type="IloOplDataElements"  javaDoc="/**
* Data elements for this OPL model.
* &lt;p&gt;Data elements can be used to create more instances of
* &lt;code&gt;IloOplModel&lt;/code&gt; with the same &lt;code&gt;.dat&lt;/code&gt; files.&lt;/p&gt;
*
* &lt;p&gt;The caller is responsible for ending the returned object.&lt;/p&gt;
* &lt;p&gt;Example:&lt;/p&gt;
* &lt;p&gt;&lt;code&gt;var data = thisOplModel.dataElements;&lt;/code&gt; //code that uses the data&lt;/p&gt;
* &lt;p&gt;&lt;code&gt;data.end(); &lt;/code&gt; //cleans the memory used by the data elements&lt;/p&gt;
* 
* &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
* &lt;/p&gt;
*
* @type IloOplDataElements
* @available flow control
*/" />
        <method name="_element_name_scalar_" isProperty="true"  type="string"  javaDoc="/**
 * A scalar OPL element by its name.
 * &lt;p&gt;Only elements of scalar type can be modified in flow control.&lt;/p&gt;
 * @available flow control (write)
 * @type string
 */" />
        <method name="addDataSource" argument1="IloOplDataSource"  javaDoc="/**
 * Adds a source for external data.
 *
 * @available flow control
 * @param dataSource An instance of &lt;code&gt;IloOplDataSource&lt;/code&gt; or &lt;code&gt;IloOplDataElements&lt;/code&gt;.
 */" />
        <method name="generate"  javaDoc="/**
 * Creates the model and extracts it.
 * @available flow control
 */" />
        <method name="isRunOnServer"  type="boolean"  javaDoc="/**
 * Checks whether model is run in server mode.
 *
 * @type boolean
 * @available flow control
 * @return &lt;code&gt;true&lt;/code&gt; if this model is run on a server
 */" />
        <method name="isUsingCplex"  type="boolean"  javaDoc="/**
* Accesses a model for the CPLEX engine.
*
* @type boolean
* @available flow control
* @return &lt;code&gt;true&lt;/code&gt; if this model is using CPLEX.
*/" />
        <method name="convertAllIntVars"  javaDoc="/**
 * Relaxes integer decision variables.
 * @available flow control
 */" />
        <method name="unconvertAllIntVars"  javaDoc="/**
 * Undoes the relaxation of all integer decision variables.
 * @available flow control
 */" />
        <method name="postProcess"  javaDoc="/**
 * Postprocesses the model.
 * @available flow control
 */" />
        <method name="printInternalData"  type="string" argument1="string"  javaDoc="/**
 * Prints all the internal data.
 * &lt;p&gt;The output is a valid &lt;code&gt;.dat&lt;/code&gt; file.&lt;/p&gt;
 *
 * @available flow control
 * @type string
 * @param {string} title optional
 * @return The string containing all the internal data.
 */" />
        <method name="printExternalData"  type="string" argument1="string"  javaDoc="/**
 * Prints all the external data.
 * &lt;p&gt;The output is a valid &lt;code&gt;.dat&lt;/code&gt; file.&lt;/p&gt;
 *
 * @available flow control
 * @type string
 * @param title optional
 * @return The string containing all the external data.
 */" />
        <method name="printSolution"  type="string"  javaDoc="/**
 * Prints the current solution values for all decision variables.
 * &lt;p&gt;The output is a valid &lt;code&gt;.dat&lt;/code&gt; file.&lt;/p&gt;
 *
 * @available flow control
 * @type string
 * @return The string containing the current solution values for all decision variables.
 */" />
        <method name="getObjective"  type="IloObjective"  javaDoc="/**
 * Gets the objective.
 *
 * @available flow control
 * @return The objective.
 * @type IloObjective
 */" />
        <method name="main"  type="int"  javaDoc="/**
 * Invokes the main scripting block of a model.
 *
 * @available flow control
 * @return The status.
 * @type int
 */" />
        <method name="relaxationIterator" isProperty="true"  type="IloOplRelaxationIterator"  javaDoc="/**
 * The default relaxation iterator for this OPL model.
 * &lt;p&gt;You can use the relaxation iterator to attach elements in order to control the
 * relaxation.&lt;/p&gt;
 *
 * @type IloOplRelaxationIterator
 * @available flow control and preprocessing
 */" />
        <method name="conflictIterator" isProperty="true"  type="IloOplConflictIterator"  javaDoc="/**
 * The default conflict iterator for this OPL model.
 * &lt;p&gt;The conflict iterator can be used to attach elements in order to control the
 * conflict refinement.&lt;/p&gt;
 *
 * @type IloOplConflictIterator
 * @available flow control and preprocessing
 */" />
        <method name="settings" isProperty="true"  type="IloOplSettings"  javaDoc="/**
 * Accesses the OPL settings for this model instance.
 *
 * @type IloOplSettings
 * @available all
 */" />
        <method name="resolvePath"  type="string" argument1="string"  javaDoc="/**
 * Resolves a resource name as file path.
 *
 * &lt;p&gt;Relative paths are resolved relative to this OPL model.&lt;/p&gt;
 *
 * @available all
 * @param name The resource name.
 * @type string
 * @return The resolved path.
 */" />
        <method name="setPoolSolution" argument1="int"  javaDoc="/**
 * Sets which solution from the solution pool to use as the solution.
 * This method works only if the embedded algorithm had been collecting a pool of solutions. 
 * If the value of the identifier, &lt;code&gt;i&lt;/code&gt;, is higher than the available number of solutions in the pool,
 * the method does nothing and returns &lt;code&gt;false&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is negative, 
 * the model is returned to the default solution state.
 *
 * @param i The identifier of the solution to use.
 * @available flow control
 */" />
        <method name="applyOpsSettings"  type="void" argument1="string" argument2="string"  javaDoc="/**
 * Applies the settings to OPL and the required engine.
 * For example: &lt;code&gt;oplModel.applyOpsSettings(null, &quot;c:/temp/mytrans.ops&quot;);&lt;/code&gt;
 * Or: &lt;code&gt;oplModel.applyOpsSettings(&quot;c:/temp/&quot;, &quot;mytrans.ops&quot;);&lt;/code&gt;
 * @param path Base directory or null
 * @param file OPS file name or OPS full path
 * @type void
 */" />
      </methods>
    </class>
    <class name="IloOplModelDefinition">
      <methods>
        <method isConstructor="true" name="IloOplModelDefinition"  type="IloOplModelDefinition" argument1="IloOplModelSource"  javaDoc="/**
 * @class
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 *
 * @iterating Default behavior.
 * @named Default behavior. 
 *
 * @example {For the following basic model:}
 * float maxOfx = ...;
 * dvar float x;
 *
 * maximize x;
 * subject to {
 *   x&lt;=maxOfx;
 * } 
 *
 * @example {and the following data:}
 *   maxOfx=10;
 * 
 * @example {Flow control script:}
 * main { 
 *   var source = new IloOplModelSource(&quot;basicmodel.mod&quot;);
 *   var cplex = new IloCplex();
 *   var def = new IloOplModelDefinition(source);
 *   var opl = new IloOplModel(def,cplex);
 *   var data = new IloOplDataSource(&quot;basicmodel.dat&quot;);
 *   opl.addDataSource(data);
 *   opl.generate();
 *   if (cplex.solve()) {
 *      writeln(&quot;OBJ = &quot; + cplex.getObjValue());
 *   } else {
 *      writeln(&quot;No solution&quot;);
 *   }
 *   var opl2 = new IloOplModel(def,cplex);
 *   var data2= new IloOplDataElements();
 *   data2.maxOfx=11;
 *   opl2.addDataSource(data2);
 *   opl2.generate();
 *
 *   if (cplex.solve()) {
 *      writeln(&quot;OBJ = &quot; + cplex.getObjValue());
 *   } else {
 *      writeln(&quot;No solution&quot;);
 *   }
 *
 *   opl.end();
 *   opl2.end();
 *   data.end(); 
 *   def.end(); 
 *   cplex.end(); 
 *   source.end(); 
 * }
 *
 * @available flow control
 * @param modelSource An instance of &lt;code&gt;IloOplModelSource&lt;/code&gt;.
 * @ilog.undocumented.jsFile
 * @extends IloObject
 */" />
        <method name="isUsingCplex"  type="boolean"  javaDoc="/**
 * Accesses a model for the CPLEX engine.
 *
 * @type boolean
 * @available flow control
 * @return &lt;code&gt;true&lt;/code&gt; if this model definition is using CPLEX.
 */" />
        <method name="modelSource" isProperty="true"  type="IloOplModelSource"  javaDoc="/**
 * The underlying model source.
 *
 * @type IloOplModelSource
 * @available flow control
 */" />
        <method name="hasMain"  type="boolean"  javaDoc="/**
 * Model with main scripting.
 *
 * @type boolean
 * @available flow control
 * @return &lt;code&gt;true&lt;/code&gt; if this model definition has a main scripting block defined.
 */" />
        <method name="isUsingCP"  type="boolean"  javaDoc="/**
 * Accesses a model for the CP Optimizer engine.
 *
 * @type boolean
 * @available flow control
 * @return &lt;code&gt;true&lt;/code&gt; if this model definition is using CP Optimizer.
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloOplModelSource">
      <methods>
        <method isConstructor="true" name="IloOplModelSource"  type="IloOplModelSource" argument1="string"  javaDoc="/**
 * @class
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 *
 * @iterating Default behavior.
 * @named Default behavior. 
 *
 * @example {For the following basic model:}
 * float maxOfx = ...;
 * dvar float x;
 *
 * maximize x;
 * subject to {
 *   x&lt;=maxOfx;
 * } 
 *
 * @example {and the following data:}
 * maxOfx=10;
 *
 * @example {Flow control script:}
 * main { 
 *   var source = new IloOplModelSource(&quot;basicmodel.mod&quot;);
 *   var cplex = new IloCplex();
 *   var def = new IloOplModelDefinition(source);
 *   var opl = new IloOplModel(def,cplex);
 *   var data = new IloOplDataSource(&quot;basicmodel.dat&quot;);
 *   opl.addDataSource(data);
 *   opl.generate();
 *   if (cplex.solve()) {
 *      writeln(&quot;OBJ = &quot; + cplex.getObjValue());
 *   } else {
 *      writeln(&quot;No solution&quot;);
 *   }
 *   var opl2 = new IloOplModel(def,cplex);
 *   var data2= new IloOplDataElements();
 *   data2.maxOfx=11;
 *   opl2.addDataSource(data2);
 *   opl2.generate();
 *
 *   if (cplex.solve()) {
 *      writeln(&quot;OBJ = &quot; + cplex.getObjValue());
 *   }  else {
 *      writeln(&quot;No solution&quot;);
 *   }
 *
 *   opl.end();
 *   opl2.end();
 *   data.end(); 
 *   def.end(); 
 *   cplex.end(); 
 *   source.end(); 
 * }
 *
 * @available flow control
 * @ilog.undocumented.jsFile
 * @extends IloObject
 */" />
        <method name="name" isProperty="true"  type="string"  javaDoc="/**
 * The name of this model source.
 * &lt;p&gt;This is the path for model file sources.&lt;/p&gt;
 *
 * @type string
 * @available flow control
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloOplOutputFile">
      <methods>
        <method isConstructor="true" name="IloOplOutputFile"  type="IloOplOutputFile" argument1="string" argument2="IloBool"  javaDoc="/**
 * @class
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 *
 * @iterating Empty iteration.
 * @named Default behavior. 
 *
 * @example
 * execute {
 *   var f = new IloOplOutputFile(&quot;output.txt&quot;);
 *   f.writeln(&quot;Hello World&quot;);		 // lazy open
 *   f.close();
 *  
 *   var f2 = new IloOplOutputFile(&quot;output.txt&quot;, true);
 *   if (f2.exists) 
 *      writeln(&quot;output.txt exists ==&gt; append mode&quot;);
 *   else 
 *      writeln(&quot;output.txt doesn&apos;t exist&quot;);
 *   f2.writeln(&quot;another line&quot;);
 *   f2.close();
 * } 
 * 
 * @example {The script creates the file &lt;code&gt;output.txt&lt;/code&gt; in the directory where the .mod file 
 * is located. After execution the Scripting log shows:}
 * 
 * output.txt exists ==&gt; append mode
 *
 * @available flow control
 * @ilog.undocumented.jsFile
 * @param path &lt;em&gt;Optional:&lt;/em&gt; The path of the file to open.
 * @param append &lt;em&gt;Optional:&lt;/em&gt; If true, sets the stream position at the end of the file.
 */" />
        <method name="write"  type="void" argument1="string" argument2="string"  javaDoc="/**
 * Writes a string to the output file.
 *
 * @available flow control
 * @param text Writes the contents of this string.
 * @param textN Optional, n strings
 */" />
        <method name="writeln" argument1="string" argument2="string"  javaDoc="/**
 * Writes one line to the output file.
 *
 * @available flow control
 * @param text Writes the contents of this string and ends with a new line.
 * @param textN Optional, n strings.
 */" />
        <method name="exists" isProperty="true"  type="boolean"  javaDoc="/**
 * @return &lt;code&gt;true&lt;/code&gt; if the file exists.
 * @type boolean
 * @available flow control
 */" />
        <method name="open" argument1="string"  javaDoc="/**
 * Opens the file on the given path.
 *
 * @available flow control
 * @param path The path of the file to open.
 * @deprecated The file is automatically opened when needed.
 */" />
        <method name="isOpen" isProperty="true"  type="boolean"  javaDoc="/**
 * @return &lt;code&gt;true&lt;/code&gt; if the file is currently open.
 * @type boolean
 * @available flow control
 * @deprecated	replaced by exists
 */" />
        <method name="close"  javaDoc="/**
 * Closes the output file. 
 * Once a file has been closed, further &lt;code&gt;write()&lt;/code&gt; invocations will cause an error. 
 * Closing a previously-closed file, however, has no effect.
 *
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloOplOutputString">
      <methods>
        <method isConstructor="true" name="IloOplOutputString"  type="IloOplOutputString"  javaDoc="/**
 * @class
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 *
 * @iterating Empty iteration.
 * @named Default behavior. 
 *
 * @example
 * execute {
 *   var str = new IloOplOutputString();
 *   with (str) {
 *     writeln(&quot;Hello World&quot;);
 *  }
 *  writeln(&quot;str = &quot;,str.getString());
 * }
 *
 * @available flow control
 * @ilog.undocumented.jsFile
 */" />
        <method name="write"  type="void" argument1="string" argument2="string"  javaDoc="/**
 * Writes a string to the output string.
 *
 * @available flow control
 * @param text The contents of the string.
 * @param textN Optional, n strings
 */" />
        <method name="writeln" argument1="string" argument2="string"  javaDoc="/**
 * Writes one line to the output string.
 *
 * @available flow control
 * @param text The contents of the string. Ends with a new line.
 * @param textN Optional, n strings.
 */" />
        <method name="getString"  type="string"  javaDoc="/**
 * Returns the content of the output string.
 * @type string
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloTuple">
      <methods>
        <method isConstructor="true" name="IloTuple"  type="IloTuple"  javaDoc="/**
 * @class
 *
 * @iterating Default behavior.
 * @named Default behavior. 
 *
 * @example
 * tuple T {
 *   int i;
 *   string s;
 * }
 *
 * T t1=&lt;1,&quot;one&quot;&gt;;
 * execute {
 *   t1.i=2;
 *   t1.s=&quot;two&quot;;
 *   writeln(&quot;t1 = &quot;,t1);
 * } 
 * 
 * @example {After execution the Scripting log shows:}
 * t1 =  &lt;2 &quot;two&quot;&gt;
 *
 * @opl-type T, where T is a declared tuple type
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 * @available all
 */" />
        <method name="_component_name" isProperty="true"  type="string"  javaDoc="/**
 * The value of the component with the given name.
 * @available all
 * @type string
 */" />
        <method name="getNFields"  type="int"  javaDoc="/**
* Returns the number of fields of this tuple.
*
* @available all
* @type int
* @return The number of fields.
*/" />
        <method name="getFieldName"  type="string" argument1="int"  javaDoc="/**
* Returns the name of the field at position &lt;code&gt;i&lt;/code&gt;.
* @example
* for (var i =0; i &lt; myTuple.getNFields(); i++) {
*   var f = myTuple.getFieldName(i);  
*   writeln(&quot;field name &quot;, f);
*   writeln(&quot;field type &quot;, typeof( myTuple[f]));
*   writeln(&quot;field value &quot;, myTuple[f]);
* }
*
* @available all
* @type string
* @return The field name.
*/" />
      </methods>
    </class>
    <class name="IloTupleSet">
      <methods>
        <method isConstructor="true" name="IloTupleSet"  type="IloTupleSet"  javaDoc="/**
 * @class
 * 
 * @iterating Iterates on the tuples in this set.
 * @named Default behavior. 
 *
 * @example
 * tuple T {
 *   int i;
 *   string s;
 * }
 * {T} 1;
 * {T} tupleset2;
 *
 * execute {
 *   tupleset1.add(1, &quot;one&quot;);
 *   tupleset1.add(2, &quot;two&quot;);
 *   tupleset2.add(tupleset1.get(1,&quot;one&quot;));
 * }
 *
 * execute{
 *   writeln(&quot;tupleset1 = &quot;,tupleset1,&quot; and tupleset1.size = &quot;,tupleset1.size);
 *   writeln(&quot;tupleset2 = &quot;,tupleset2,&quot; and tupleset2.size = &quot;,tupleset2.size);  
 * }
 * 
 * @example {After execution&#44; the Scripting log shows:}
 * tupleset1 =  {&lt;1 &quot;one&quot;&gt; &lt;2 &quot;two&quot;&gt;} and tupleset1.size = 2
 * tupleset2 =  {&lt;1 &quot;one&quot;&gt;} and tupleset2.size = 1
 *
 * @opl-type {T}, where T is a declared tuple type
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 * @available all
 * @extends IloDiscreteDataCollection
 */" />
        <method name="getNFields"  type="int"  javaDoc="/**
* Returns the number of fields of the tuple of this set.
*
* @available all
* @type int
* @return The number of fields.
*/" />
        <method name="getFieldName"  type="string" argument1="int"  javaDoc="/**
* Returns the name of the field at position &lt;code&gt;i&lt;/code&gt;.
* @example
* writeln(&quot;Tuple:&quot;);
* for (var i =0; i &lt; ts.getNFields(); i++) {
*   var f = ts.getFieldName(i);  
*   writeln(&quot;  field name: &quot;, f );
* }
*
* @available all
* @type string
* @return The field name.
*/" />
        <method name="find"  type="IloTuple" argument1="undefined" argument2="undefined"  javaDoc="/**
 * Finds the tuple with the component values you pass as parameters. 
 * &lt;p&gt;You can pass all the components or all the key components, 
 *  in the order of declaration of the tuple type.&lt;/p&gt;
 * &lt;p&gt;If no tuple exists, the value &lt;code&gt;null&lt;/code&gt; is returned.&lt;/p&gt;
 *
 * @available all
 * @type IloTuple
 * @param componentValue The value for the first tuple component or key component.
 * @param componentValueN The value for the n-th tuple component or key component.
 * @return The tuple with the given component values, or &lt;code&gt;null&lt;/code&gt;.
 */" />
        <method name="get"  type="IloTuple" argument1="undefined" argument2="undefined"  javaDoc="/**
 * Gets the tuple with the component values you pass as parameters.
 * &lt;p&gt;You can pass all the components or all the key components, 
 *  in the order of declaration of the tuple type.&lt;/p&gt;
 * &lt;p&gt;If no tuple exists, a runtime error is raised.&lt;/p&gt;
 *
 * @available all
 * @type IloTuple
 * @param componentValue The value for the first tuple component or key component.
 * @param componentValueN The value for the n-th tuple component or key component.
 * @return The tuple with the given component values, or raises an error.
 */" />
        <method name="addOnly" argument1="undefined" argument2="undefined"  javaDoc="/**
 * Adds a new tuple with the given component values, without returning the tuple.
 * &lt;p&gt;The values are passed in the order of declaration of the tuple type.&lt;/p&gt;
 * &lt;p&gt;This method is faster than &lt;code&gt;add()&lt;/code&gt; and uses less memory as it returns nothing.&lt;/p&gt;
 *
 * @available all
 * @param componentValue The value for the first tuple component.
 * @param componentValueN The value for the n-th tuple component.
 * @return Nothing.
 */" />
        <method name="add"  type="IloTuple" argument1="undefined" argument2="undefined"  javaDoc="/**
 * Adds a new tuple with the given component values.
 * &lt;p&gt;The values are passed in the order of declaration of the tuple type.&lt;/p&gt;
 * &lt;p&gt;If the tuple already exists, the method returns the existing tuple.&lt;/p&gt;
  * &lt;p&gt;If the set is sorted, all previous instances of tuples will be invalidated.&lt;/p&gt;
 * &lt;p&gt;The fastest method to populate a set is to use &lt;code&gt;addOnly()&lt;/code&gt;.&lt;/p&gt;
 *
 * @available all
 * @type IloTuple
 * @param componentValue The value for the first tuple component.
 * @param componentValueN The value for the n-th tuple component.
 * @return The tuple with the given component values or the already existing tuple.
 */" />
        <method name="remove" argument1="undefined" argument2="undefined"  javaDoc="/**
 * Removes the tuple. Does nothing if the expected item does not exist.
 *
 * @param componentValue The value for the first tuple component.
 * @param componentValueN The value for the n-th tuple component.
 * @available all
 */" />
        <method name="clear"  type="void"  javaDoc="/**
 * Removes all tuples from the set.
 *
 * @available all
 * @return Nothing.
 */" />
        <method name="importSet" argument1="tSet"  javaDoc="/**
* Adds an external tupleset.
*
* @available all
* @param tSet The tupleSet to add to the current one.
* @return Nothing.
*/" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available flow control
 */" />
        <method name="size" isProperty="true"  type="int"  javaDoc="/**
 * The number of items in this collection.
 * @type int
 * @available all
 */" />
        <method name="addAll" argument1="IloDiscreteDataCollection"  javaDoc="/**
 * Adds several items to this collection using built-in arrays.
 *
 * @example
 * {int} s={}
 *
 * execute {
 *  writeln(s.size, &quot; is the size of &quot;,s); 
 *  s.addAll(new Array(1,2,3,4));
 *  writeln(s.size, &quot; is the size of &quot;,s); 
 * }
 *
 * @param itemArray An array with items to add to this collection.
 * @available all
 */" />
        <method name="contains"  type="boolean" argument1="IloObject"  javaDoc="/**
 * Returns whether the item is contained in this collection.
 *
 * @param item The item to look for in this collection.
 * @return &lt;code&gt;true&lt;/code&gt; if the item is in the collection.
 * @type boolean
 * @available all
 */" />
        <method name="isSorted"  type="boolean"  javaDoc="/**
 * Returns whether the collection is sorted or not.
 *
 * @return &lt;code&gt;true&lt;/code&gt; if the collection is sorted.
 * @type boolean
 * @available all
 */" />
        <method name="isReversed"  type="boolean"  javaDoc="/**
 * Returns whether the collection is reversed or not.
 *
 * @return &lt;code&gt;true&lt;/code&gt; if the collection is reversed.
 * @type boolean
 * @available all
 */" />
        <method name="isOrdered"  type="boolean"  javaDoc="/**
 * Returns whether the collection is ordered or not.
 *
 * @return &lt;code&gt;true&lt;/code&gt; if the collection is ordered.
 * @type boolean
 * @available all
 */" />
        <method name="clearAllCaches"  javaDoc="/**
 * @ignore
 *
 * Clears all internal caches for this collection.
 * @available all
 */" />
      </methods>
    </class>
    <class name="IloOplRunConfiguration">
      <methods>
        <method isConstructor="true" name="IloOplRunConfiguration"  type="IloOplRunConfiguration" argument1="string" argument2="string" argument3="string"  javaDoc="/**
 * @class
 * The instances of this class help execute run configurations associating model and data.
 * It controls the life cycle of underlying objects.
 *
 * &lt;p&gt;Relative file paths are resolved relatively to the path of the current model file.
 * &lt;/p&gt;
 *
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 *
 * @iterating Default behavior.
 * @named Default behavior.
 *
 * @ilog.undocumented.jsFile
 * @available all
 *
 * @see IloOplModelSource
 * @see IloOplModelDefinition
 * @see IloCplex
 * @see IloOplModel
 * @see IloOplDataSource
 *
 * @param modPath The path to the model file, or a model definition.
 * @param datPath The path to a data file, or data elements.
 * @param datPathN The path to the n-th data file.
 * @extends IloObject
 */" />
        <method name="cplex" isProperty="true"  type="IloCplex"  javaDoc="/**
 * Accesses the CPLEX object for this run configuration.
 * If no CPLEX object has been set, the run configuration will create a new one.
 *
 * @type IloCplex
 * @available flow control (read/write)
 */" />
        <method name="settings" isProperty="true"  type="IloOplSettings"  javaDoc="/**
 * Accesses the OPL settings object for this run configuration.
 * If no OPL settings object has been set, the run configuration will create a new one.
 *
 * @type IloOplSettings
 * @available flow control (read/write)
 */" />
        <method name="oplModel" isProperty="true"  type="IloOplModel"  javaDoc="/**
 * Accesses the OPL model instance for this run configuration.
 *
 * @type IloOplModel
 * @available flow control (read only)
 */" />
        <method name="cp" isProperty="true"  type="IloCplex"  javaDoc="/**
 * Accesses the CPLEX object for this run configuration.
 * If no CPLEX object has been set, the run configuration will create a new one.
 *
 * @type IloCplex
 * @available flow control (read/write)
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloOplProject">
      <methods>
        <method isConstructor="true" name="IloOplProject"  type="IloOplProject" argument1="string"  javaDoc="/**
 * @class
 * The instances of this class help access run configurations
 * configured in an OPL project file by associating model and data.
 *
 * &lt;p&gt;Relative file paths are resolved relatively to the path of the current model file.
 * &lt;/p&gt;
 *
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 *
 * @iterating Default behavior.
 * @named Default behavior.
 *
 * @ilog.undocumented.jsFile
 * @available all
 *
 * @see IloOplRunConfiguration
 *
 * @param prjPath The path to the project folder.
 * @extends IloObject
 */" />
        <method name="makeRunConfiguration"  type="IloOplRunConfiguration" argument1="string"  javaDoc="/**
 * Creates a new run configuration, as configured by the OPL project.
 * &lt;p&gt;The caller is responsible for ending that object.
 * &lt;/p&gt;
 *
 * @type IloOplRunConfiguration
 * @return The run configuration configured in the project.
 * @param name optional: The name of the run configuration. If no name is specified, the method uses the default run configuration.
 * @available flow control
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloOplSettings">
      <methods>
        <method isConstructor="true" name="IloOplSettings"  type="IloOplSettings"  javaDoc="/**
 * @class
 * Accesses OPL settings.
 *
 * &lt;p&gt;Relative file paths are resolved relatively to the path of the current model file.
 * &lt;/p&gt;
 *
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 *
 * @iterating Iterates on names of OPL settings with values that are different from their default.
 * @named Default behavior.
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 * @available all
 *
 * @see IloOplModel#settings
 */" />
        <method name="GC" isProperty="true"  type="boolean"  javaDoc="/**
* Tells OPL to enable/disable the JavaScript garbage collector.
* Default: &lt;code&gt;true&lt;/code&gt;
*
* @type boolean
* @available all
*/" />
        <method name="locations" isProperty="true"  type="boolean"  javaDoc="/**
 * Maintains the information on file location for runtime objects.
 * Useful for debugging.
 * Default: &lt;code&gt;false&lt;/code&gt;
 *
 * @type boolean
 * @available all
 */" />
        <method name="dvarNames" isProperty="true"  type="boolean"  javaDoc="/**
 * The names of decision variables at runtime.
 * Useful for debugging.
 * Default: &lt;code&gt;false&lt;/code&gt;
 *
 * @type boolean
 * @available all
 */" />
        <method name="warnings" isProperty="true"  type="boolean"  javaDoc="/**
 * Enables warnings.
 * Default: &lt;code&gt;true&lt;/code&gt;
 *
 * @type boolean
 * @available all
 */" />
        <method name="forceUsage" isProperty="true"  type="boolean"  javaDoc="/**
 * Forces the use of model elements. Instantiates all the model elements declared.
 * Default: &lt;code&gt;false&lt;/code&gt;
 *
 * @type boolean
 * @available all
 */" />
        <method name="displayWidth" isProperty="true"  type="int"  javaDoc="/**
 * Sets the display width. Breaks the lines that have more characters.
 * Default: 75
 *
 * @type int
 * @available all
 */" />
        <method name="displayPrecision" isProperty="true"  type="int"  javaDoc="/**
 * Sets the display precision, that is, the number of fractional digits to display for float numbers.
 * Default: 4
 *
 * @type int
 * @available all
 */" />
        <method name="displayIndex" isProperty="true"  type="boolean"  javaDoc="/**
 * Displays array items with their index value.
 * Default: &lt;code&gt;false&lt;/code&gt;
 *
 * @type boolean
 * @available all
 */" />
        <method name="displayComponentName" isProperty="true"  type="boolean"  javaDoc="/**
 * Displays tuple component values with their names.
 * Default: &lt;code&gt;false&lt;/code&gt;
 *
 * @type boolean
 * @available all
 */" />
        <method name="displayOnePerLine" isProperty="true"  type="boolean"  javaDoc="/**
 * Displays one collection item per line.
 * Default: &lt;code&gt;false&lt;/code&gt;
 *
 * @type boolean
 * @available all
 */" />
        <method name="dbExecuteFailOnError" isProperty="true"  type="boolean"  javaDoc="/**
 * Raises runtime errors if a &lt;code&gt;DBExecute&lt;/code&gt; statement fails.
 * Otherwise, a warning is displayed.
 * Default: &lt;code&gt;false&lt;/code&gt;
 *
 * @type boolean
 * @available all
 */" />
        <method name="dbUpdateBatchSize" isProperty="true"  type="int"  javaDoc="/**
 * Batch size for database updates.
 * Sends bulk updates with this number of rows.
 * Otherwise, a warning is displayed.
 * Default: 3000
 *
 * @type int
 * @available all
 */" />
        <method name="datachecks" isProperty="true"  type="boolean"  javaDoc="/**
* Tells OPL to check, or not, the data integrity coming from databases or flat files.
* If you are sure of non duplicated items in the sets you are reading you can use this setting to go faster.
* Default: &lt;code&gt;true&lt;/code&gt;
*
* @type boolean
* @available all
*/" />
        <method name="dbReadBatchSize" isProperty="true"  type="int"  javaDoc="/**
 * Batch size for database read.
 * Reads with this number of rows.
 * Default: 1
 *
 * @type int
 * @available all
 */" />
        <method name="bigMapThreshold" isProperty="true"  type="int"  javaDoc="/**
 * Some activities on arrays are reduced on big instances to save memory and time.
 * These activities include naming and display.
 * Default: 100
 *
 * @type int
 * @available all
 */" />
        <method name="mainEndEnabled" isProperty="true"  type="boolean"  javaDoc="/**
 * Enables execution of &lt;code&gt;end&lt;/code&gt; methods from flow control scripting.
 * Default: &lt;code&gt;true&lt;/code&gt;
 *
 *
 * @type boolean
 * @available all
 */" />
        <method name="_memoryEmphasis" isProperty="true"  type="boolean"  javaDoc="/**
 * @ignore
 *
 * Emphasizes memory consumption during execution.
 * Default: &lt;code&gt;false&lt;/code&gt;
 *
 * @type boolean
 * @available all
 */" />
        <method name="names" isProperty="true"  type="boolean"  javaDoc="/**
 * Generates names for runtime objects.
 * Useful for debugging.
 * Default: &lt;code&gt;false&lt;/code&gt;
 *
 * @type boolean
 * @available all
 */" />
        <method name="skipAssert" isProperty="true"  type="boolean"  javaDoc="/**
 * Skips execution of all &lt;code&gt;assert&lt;/code&gt; statements.
 * Useful for debugging.
 * Default: &lt;code&gt;false&lt;/code&gt;
 *
 * @type boolean
 * @available all
 */" />
        <method name="relaxationLevel" isProperty="true"  type="int"  javaDoc="/**
 * Changes the way automatic relaxation of infeasible models is done.
 * Default: 0
 * &lt;br /&gt;
 * Value 0 means that all variables and labelled constraints can be relaxed.
 * Value 1 means that only labelled constraints can be relaxed.
 *
 * @type int
 * @available all
 */" />
        <method name="mainNewEngineEnv" isProperty="true"  type="int"  javaDoc="/**
* Changes the way submodels are allocated.
* Default: 1
*
* Value 1 means that a new instance of &lt;code&gt;IloOplModel&lt;/code&gt; with a new algorithm is allocated separately from the main model.
* Value 0 means that all models are allocated to the same stack. Use the value 0 when multi-model applications get non expected results.
*
* @type int
* @available all
*/" />
        <method name="VMConfig" isProperty="true"  type="string"  javaDoc="/**
 * Name of the CPLEX virtual machine file
 * Default: &lt;code&gt;null&lt;/code&gt;
 *
 * @type string
 * @available all
 */" />
        <method name="exportExternalData" isProperty="true"  type="string"  javaDoc="/**
 * Name of the file to which OPL will export the external data.
 * Default: &lt;code&gt;null&lt;/code&gt;
 *
 * @type string
 * @available all
 */" />
        <method name="exportInternalData" isProperty="true"  type="string"  javaDoc="/**
 * Name of the file to which OPL will export the internal data.
 * Default: &lt;code&gt;null&lt;/code&gt;
 *
 * @type string
 * @available all
 */" />
        <method name="slicingCache" isProperty="true"  type="boolean"  javaDoc="/**
 * Tells OPL to index the data for filtering or not.
 * Default: &lt;code&gt;true&lt;/code&gt;
 *
 * @type boolean
 * @available all
 */" />
      </methods>
    </class>
    <class name="IloCP">
      <methods>
        <method isConstructor="true" name="IloCP"  type="IloCP"  javaDoc="/**
* @class
*
* @iterating Default behavior.
* @named Default behavior.
* @available flow control
* @ilog.undocumented.jsFile
* @extends IloObject
*/" />
        <method name="clearModel"  javaDoc="/**
 * Resets CP Optimizer to accept another CP model.
 *
 * @available flow control
 */" />
        <method name="exportModel" argument1="string"  javaDoc="/**
 * Exports the CP model to a file.
 * Relative paths are resolved with respect to the current model file.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * @param path Path of the file to which the model will be exported.
 * @available flow control
 */" />
        <method name="importModel" argument1="string"  javaDoc="/**
 * Imports the IloCP model from a file.
 * Relative paths are resolved with respect to the current model file.
 * For more information, see the class &lt;code&gt;IloCP&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 *
 * @param path Path to the file from which the model will be imported.
 * @available flow control
 */" />
        <method name="getObjValue"  type="float" argument1="int"  javaDoc="/**
 * Accesses the value of the objective, or values of a multi-criteria objective, of the current solution. 
 * The optional parameter allows you to specify the index of the value when performing optimization 
 * with a multi-criteria objective.  In the case of a multi-criteria objective, if no argument is passed, 
 * the method returns the value of the first criterion.
 *
 * @type float
 * @param i Optional parameter to give the objective position .
 * @return The objective value(s) of the current solution.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getObjBound"  type="float" argument1="int"  javaDoc="/**
 * Accesses the value of the best bound on the objective, or values of a multi-criteria best bound on the objective, of the current solution. 
 * The optional parameter allows you to specify the index of the value when performing optimization 
 * with a multi-criteria objective.  In the case of a multi-criteria objective, if no argument is passed, 
 * the method returns the value of the first criterion.
 *
 * @type float
 * @param i Optional parameter to give the objective position .
 * @return The best bound on the objective value(s) of the current solution.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="dumpModel" argument1="string"  javaDoc="/**
* Dumps the CP model to a file.
* Relative paths are resolved with respect to the current model file.
* See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
*
* @param path Path of the file to which the model will be dumped.
* @available flow control
*/" />
        <method name="param" isProperty="true"  type="IloOplScriptHCpParams"  javaDoc="/**
 * Accesses CP parameters.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * &lt;p&gt;Parameters are available by their names.&lt;/p&gt;
 * @example
 * cp.param.TimeLimit = 13;
 *
 * @example {Symbolic parameter values are assigned as strings.}
 *   cp.param.LogVerbosity = &quot;Quiet&quot;;
 * @type IloOplScriptHCpParams
 * @available all
 */" />
        <method name="info" isProperty="true"  type="IloOplScriptHCpInfos"  javaDoc="/**
 * Accesses CP information.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * &lt;p&gt;Information elements are available by their names.&lt;/p&gt;
 * @example
 *   cp.info.TotalTime
 * @type IloOplScriptHCpInfos
 * @available all
 */" />
        <method name="factory" isProperty="true"  javaDoc="/**
 * Accesses the CP search modifier factory.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * &lt;p&gt;Search modifiers are created by method calls.&lt;/p&gt;
 * @example
 *   cp.factory.selectLargest()
 *   cp.factory.domainSize()
 *
 * @example {Search phases can be created like this:}
 *   var phase;
 *   var phase2;
 *   with ( cp.factory ) {
 *      phase = searchPhase( selectLargest(domainSize()), selectSmallest(value()) );
 *      phase2 = searchPhase( x, selectLargest(domainSize()), selectSmallest(value()) );
 *   } 
 *
 * @example {where &lt;code&gt;x&lt;/code&gt; is an array of decision variables defined in the OPL model.}
 *
 * @available pre processing, flow control
 */" />
        <method name="setSearchPhases" argument1="IloSearchPhase" argument2="IloSearchPhase"  javaDoc="/**
 * Modifies the search strategy.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * &lt;p&gt;If called with no arguments, the search is reset to the default search.
 * &lt;/p&gt;
 * 
 * @see IloSearchPhase
 *
 * @available flow control
 * @param phase Use this search phase, optional.
 * @param phaseN Use n search phases.
 */" />
        <method name="getNumberOfObjValues"  type="int"  javaDoc="/**
 * Returns the number of objective criteria in the invoking instance of &lt;code&gt;IloCP&lt;/code&gt;.
 * 
 * @type int
 * @return The number of objective values.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="hasObjective"  type="boolean"  javaDoc="/**
 * This method returns &lt;code&gt;true&lt;/code&gt; if the invoking algorithm 
 * has an objective and &lt;code&gt;false&lt;/code&gt; otherwise.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * @return &lt;code&gt;true&lt;/code&gt; if it has an objective.
 * @type boolean
 * @available postprocessing
 * @available flow control
 */" />
        <method name="next"  type="boolean"  javaDoc="/**
 * This method searches for a new (or first) solution to the model.
 * In the case of an optimization problem (with an objective in the model),
 * the &lt;code&gt;next&lt;/code&gt; method finds a solution strictly better than the previous solution found.
 * In the case of a satisfaction problem (no objective in the model), &lt;code&gt;next&lt;/code&gt; returns a 
 * solution that is usually different from those previously found. However, it may occasionally 
 * find a solution that had been found already.  If you repeat calls to the &lt;code&gt;next&lt;/code&gt; function, 
 * until it returns &lt;code&gt;false&lt;/code&gt;, the solve is guaranteed to terminate and you will not miss 
 * any solutions of the model being solved. 


 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * @type boolean
 * @return &lt;code&gt;true&lt;/code&gt; if a next solution is available.
 * @available flow control
 */" />
        <method name="startNewSearch"  javaDoc="/**
 * Starts a new search.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * @available flow control
 */" />
        <method name="endSearch"  javaDoc="/**
 * Ends the current search and deletes the internal objects created by CP Optimizer to carry out the search.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * @available flow control
 */" />
        <method name="setStartingPoint" argument1="IloOplCPSolution"  javaDoc="/**
 * Sets starting point for subsequent searches.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * @param startingPoint the starting point
 * @available flow control
 * @see IloOplCPSolution
 */" />
        <method name="clearStartingPoint"  javaDoc="/**
 * Removes any starting point.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * @available flow control
 */" />
        <method name="status" isProperty="true"  type="int"  javaDoc="/**
* Status of the last method invoked on this object.
*
* @type int
* @available flow control
*/" />
        <method name="solve"  type="boolean"  javaDoc="/**
 * Solves a problem.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * @type boolean
 * @return &lt;code&gt;true&lt;/code&gt; if the solve has been successful.
 * @available flow control
 */" />
         <method name="addKPI"  argument1="dexpr int" argument2="string" javaDoc="/**
 * Adds a named KPI.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * @param expr The decision expression
 * @param name The name of the KPI
 * @available flow control
 */" />
 <method name="addKPI"  argument1="dexpr float" argument2="string" javaDoc="/**
 * Adds a named KPI.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * @param expr The decision expression
 * @param name The name of the KPI
 * @available flow control
 */" />
 <method name="removeKPI"  argument1="string" javaDoc="/**
 * Removes a named KPI.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * @param name The name of the KPI
 * @available flow control
 */" />
 <method name="removeAllKPIs" javaDoc="/**
 * Removes all KPIs.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
  * @available flow control
 */" />
 <method name="getKPIValue" type="float" argument1="string" javaDoc="/**
 * Access a KPI value.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * @param name The name of the KPI
 * @return The value of the KPI
 * @available flow control
 */" />
 <method name="getAllKPINames" type="arrayof_string" javaDoc="/**
 * Access KPI names.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * @return The names of the KPI
 * @available flow control
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Ends the current search and deletes the internal objects created by CP Optimizer to carry out the search.
 * See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
 *
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloOplCPSolution">
      <methods>
        <method isConstructor="true" name="IloOplCPSolution"  type="IloOplCPSolution"  javaDoc="/**
 * @class
 * See the class &lt;code&gt;IloCP&lt;/code&gt; in the C++ Reference Manual:&lt;br /&gt;
 * IDE and OPL &gt; OPL Interfaces &gt; C++ interface reference manual &gt; optim.cpoptimizer &gt; Classes
 *
 * @available flow control
 * @ilog.undocumented.jsFile
 */" />
        <method name="setStart" argument1="arrayof_dvar interval" argument2="arrayof_dvar interval"  javaDoc="/**
* See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
*
* @param {intVar, intVarMap, intervalVar,intervalVarMap} intVar
* @param {int, intMap, intervalVar, intervalVarMap} i
* @available flow control
*/" />
        <method name="setValue" argument1="arrayof_dvar interval" argument2="arrayof_dvar interval"  javaDoc="/**
* See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
*
* @param {intVar, intVarMap, intervalVar,intervalVarMap} intVar
* @param {int, intMap, intervalVar, intervalVarMap} i
* @available flow control
*/" />
        <method name="setMax" argument1="arrayof_dvar int" argument2="arrayof_int"  javaDoc="/**
* See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
*
* @param {intVar, intVarMap} intVar
* @param {int, intMap} i 
* @available flow control
*/" />
        <method name="setMin" argument1="arrayof_dvar int" argument2="arrayof_int"  javaDoc="/**
* See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
*
* @param {intVar, intVarMap} intVar
* @param {int, intMap} i 
* @available flow control
*/" />
        <method name="setStartMax" argument1="arrayof_dvar interval" argument2="arrayof_dvar interval"  javaDoc="/**
* See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
*
* @param {intVar, intVarMap, intervalVar,intervalVarMap} intVar
* @param {int, intMap, intervalVar, intervalVarMap} i
* @available flow control
*/" />
        <method name="setStartMin" argument1="arrayof_dvar interval" argument2="arrayof_dvar interval"  javaDoc="/**
* See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
*
* @param {intVar, intVarMap, intervalVar,intervalVarMap} intVar
* @param {int, intMap, intervalVar, intervalVarMap} i
* @available flow control
*/" />
        <method name="setEnd" argument1="arrayof_dvar interval" argument2="arrayof_dvar interval"  javaDoc="/**
* See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
*
* @param {intVar, intVarMap, intervalVar,intervalVarMap} intVar
* @param {int, intMap, intervalVar, intervalVarMap} i
* @available flow control
*/" />
        <method name="setEndMax" argument1="arrayof_dvar interval" argument2="arrayof_dvar interval"  javaDoc="/**
* See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
*
* @param {intVar, intVarMap, intervalVar,intervalVarMap} intVar
* @param {int, intMap, intervalVar, intervalVarMap} i
* @available flow control
*/" />
        <method name="setEndMin" argument1="arrayof_dvar interval" argument2="arrayof_dvar interval"  javaDoc="/**
* See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
*
* @param {intVar, intVarMap, intervalVar,intervalVarMap} intVar
* @param {int, intMap, intervalVar, intervalVarMap} i
* @available flow control
*/" />
        <method name="setOptionality" argument1="arrayof_dvar float" argument2="arrayof_float"  javaDoc="/**
 * Sets the presence status of each interval variable of map &lt;code&gt;dvars&lt;/code&gt; in the invoking solution 
 * to the value specified in map &lt;code&gt;values&lt;/code&gt;. If the value is -1, the presence status of 
 * the interval variable is set to false. If the value is +1, the presence status of the 
 * interval variable is set to true. If the value is 0, the presence/absence status of the 
 * interval variable is unbound. The two maps &lt;code&gt;dvars&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; must be indexed in the same way.
 *
 * @param {intervalVarMap} dvars
 * @param {intMap} values
 */" />
        <method name="setPresence" argument1="arrayof_dvar interval" argument2="arrayof_dvar interval"  javaDoc="/**
* See the C++ reference manual for &lt;code&gt;IloCP&lt;/code&gt;.
*
* @param {intervalVar,intervalVarMap} intervalVar
* @param {intervalVar, intervalVarMap} intervalVar2
* @available flow control
*/" />
        <method name="setOptional" argument1="dvar interval"  javaDoc="/**
 * Sets the presence status of each interval variable of map &lt;code&gt;dvars&lt;/code&gt; in the invoking solution 
 * to the value specified in map &lt;code&gt;values&lt;/code&gt;. If the value is -1, the presence status of 
 * the interval variable is set to false. If the value is +1, the presence status of the 
 * interval variable is set to true. If the value is 0, the presence/absence status of the 
 * interval variable is unbound. The two maps &lt;code&gt;dvars&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; must be indexed in the same way.
 *
 * @param {intervalVarMap} dvars
 * @param {intMap} values
 */" />
        <method name="setAbsent" argument1="dvar interval"  javaDoc="/**
 * Sets the absence status of interval variable &lt;code&gt;interval&lt;/code&gt; to be true in the invoking solution. 
 * If the invoking solution does not contain the interval variable, this function will automatically add it.
 *
 * @param interval An interval variable
 * @available flow control
 */" />
        <method name="setPresent" argument1="dvar interval"  javaDoc="/**
 * Sets the presence status of interval variable &lt;code&gt;interval&lt;/code&gt; to be true in the invoking solution. 
 * If the invoking solution does not contain the interval variable, this function will automatically add it.
 *
 * @param interval An interval variable
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloCP_factory">
      <methods>
        <method isConstructor="true" name="IloCP_factory"  type="IloCP_factory"  javaDoc="/**
* @ilog.undocumented.constructor
* @ilog.undocumented.jsFile
* @ignore
*/" />
        <method name="searchPhase"  javaDoc="/**
 * @ignore
 */" />
        <method name="selectLargest"  javaDoc="/**
 * @ignore
 */" />
        <method name="selectSmallest"  javaDoc="/**
 * @ignore
 */" />
        <method name="selectRandomValue"  javaDoc="/**
 * @ignore
 */" />
        <method name="selectRandomVar"  javaDoc="/**
 * @ignore
 */" />
      </methods>
    </class>
    <class name="IloIntervalSequenceVar">
      <methods>
        <method isConstructor="true" name="IloIntervalSequenceVar"  type="IloIntervalSequenceVar"  javaDoc="/**
 * @class
 * &lt;p&gt;&lt;em&gt;Iterating Properties:&lt;/em&gt;
 * Default behavior.
 * &lt;/p&gt;
 *
 * @example
 * using CP;
 * 
 * range R = 1..3;
 * 
 * dvar interval tia[i in R] size i;
 * dvar sequence seq in tia;
 *
 * subject to {
 *   noOverlap(seq);
 *
 *   before(seq, tia[2], tia[3]);
 *   prev(seq, tia[1], tia[3]);
 * }
 * 
 * execute {
 *   writeln(seq);
 *   writeln(seq.first() );
 *   writeln(seq.next(seq.first() ) );
 *   writeln(seq.last() );
 *
 *   writeln(&quot;loop&quot;); 
 *   var s=seq.first(); 
 *   for(var i in R) 
 *   {
 *    writeln(s); 
 *    s=seq.next(s) ; 
 *   } 
 *   writeln(s); 
 * }
 * 
 * @example {After execution the Scripting log shows:}
 * &lt;1 0 2 2&gt;
 * &lt;1 2 3 1&gt;
 * &lt;1 3 6 3&gt;
 * loop
  * &lt;1 0 2 2&gt;
 * &lt;1 2 3 1&gt;
 * &lt;1 3 6 3&gt;
 * null
 *
 * @opl-type dvar sequence
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 */" />
        <method name="name" isProperty="true"  type="string"  javaDoc="/**
 * The name of the interval sequence variable.
 * @type string
 */" />
        <method name="next"  type="IloIntervalVar"  javaDoc="/**
 * Provides access to an interval sequence variable.
 *
 * @type IloIntervalVar
 * @param x An interval variable in the sequence.
 * @return The successor of x in the interval sequence.
 * @available postprocessing
 */" />
        <method name="last"  type="IloIntervalVar"  javaDoc="/**
 * Provides access to an interval sequence variable.
 *
 * @type IloIntervalVar
 * @return The last interval of the interval sequence.
 * @available postprocessing
 */" />
        <method name="prev"  type="IloIntervalVar"  javaDoc="/**
 * Provides access to an interval sequence variable.
 *
 * @type IloIntervalVar
 * @param x An interval variable in the sequence.
 * @return The predecessor of x in the interval sequence.
 * @available postprocessing
 */" />
        <method name="first"  type="IloIntervalVar"  javaDoc="/**
 * Provides access to an interval sequence variable.
 *
 * @type IloIntervalVar
 * @return The first interval of the interval sequence.
 * @available postprocessing
 */" />
      </methods>
    </class>
    <class name="IloIntervalVar">
      <methods>
        <method isConstructor="true" name="IloIntervalVar"  type="IloIntervalVar"  javaDoc="/**
 * @class
 *
 * @iterating Default behavior.
 *
 * @example
 * dvar interval x in 2..20 size 10;
 *
 * subject to {
 *   executed( x ) == 1;
 * }
 *
 * execute {
 *   writeln(x);  
 *   writeln(x.start,&quot; &quot;,x.end);
 * }
 *
 * @example {After execution, the Scripting log shows:}
 * &lt;1 2 12 10 10&gt;
 * 2 12
 *
 * @opl-type dvar interval
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 */" />
        <method name="length" isProperty="true"  type="int"  javaDoc="/**
 * Provides access to the length property of the interval variable.
 * @available all (read only)
 * @type int
 */" />
        <method name="end" isProperty="true"  type="int"  javaDoc="/**
 * Provides access to the end time property of the interval variable.
 * @available post processing (read only)
 * @type int
 */" />
        <method name="name" isProperty="true"  type="string"  javaDoc="/**
 * The name of the interval variable.
 * @type string
 */" />
        <method name="present" isProperty="true"  type="int"  javaDoc="/**
 * Provides access to the present property of the interval variable.
 * 1 if the interval is present and 0 otherwise.
 * @type int
 * @available post processing (read only)
 */" />
        <method name="start" isProperty="true"  type="int"  javaDoc="/**
 * Provides access to the start time property of the interval variable.
 * @available post processing (read only)
 * @type int
 */" />
        <method name="inMin" isProperty="true"  type="int"  javaDoc="/**
 * Access to the declared minimum for start time property of the interval variable,
 * using &apos;in&apos; keyword.
 * @available all (read only)
 * @type int
 */" />
        <method name="inMax" isProperty="true"  type="int"  javaDoc="/**
 * Access to the declared maximum for end time property of the interval variable,
 * using &apos;in&apos; keyword.
 * @available all (read only)
 * @type int 
 */" />
        <method name="sizeMin" isProperty="true"  type="int"  javaDoc="/**
 * Access to the declared minimum for size property of the interval variable
 * @available all (read only)
 * @type int
 */" />
        <method name="sizeMax" isProperty="true"  type="int"  javaDoc="/**
 * Access to the declared maximum for size property of the interval variable
 * @available all (read only)
 * @type int
 */" />
        <method name="absent" isProperty="true"  type="int"  javaDoc="/**
 * Access to the absence property of the interval variable. 
 *
 * @return 0 if the interval is present and 1 otherwise.
 * @available postprocessing (read only)
 * @type int
 */" />
        <method name="size" isProperty="true"  type="int"  javaDoc="/**
 * Provides access to the size property of the interval variable.
 * @available post processing (read only)
 * @type int
 */" />
      </methods>
    </class>
    <class name="IloCumulFunctionExpr">
      <methods>
        <method isConstructor="true" name="IloCumulFunctionExpr"  type="IloCumulFunctionExpr"  javaDoc="/**
 * @class
 * &lt;p&gt;An OPL class that uses the cumulative function (scheduling).&lt;/p&gt;
 *
 * @example
 * An example using the cumulative function is provided with your installation. See:
 * &lt;Install_dir&gt;\opl\examples\opl\sched_cumul\sched_cumul.mod
 *
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 */" />
        <method name="getNumberOfSegments"  type="int"  javaDoc="/**
 * Returns the number of segments of a cumulative function.
 *
 * @type int
 * @return The number of segments of the corresponding stepwise non-negative function. 
 * A segment is an interval [start, end) on which the value of the function is constant.
 * @available postprocessing
 */" />
        <method name="getSegmentStart"  type="int" argument1="int"  javaDoc="/**
 * Returns the start of a segment of a cumulative function.
 * @param i Segment position 
 * @type int
 * @return The start of the ith segment of the corresponding stepwise non-negative function.
 * @available postprocessing
 */" />
        <method name="getSegmentEnd"  type="int" argument1="int"  javaDoc="/**
 * Returns the end of a segment of a cumulative function.
 * @param i   Segment position 
 * @type int
 * @return The end of the ith segment of the corresponding stepwise non-negative function.
 * @available postprocessing
 */" />
        <method name="getSegmentValue"  type="int" argument1="int"  javaDoc="/**
 * Returns the value of a segment of a cumulative function.
 * @param i   Segment position 
 * @type int
 * @return The value of the ith segment of the corresponding stepwise non-negative function.
 * @available postprocessing
 */" />
        <method name="getValue"  type="int" argument1="int"  javaDoc="/**
 * Returns the value of a cumulative function at a given point.
 * @param i A point
 * @type int
 * @return The value of the corresponding stepwise non-negative function at point i.
 * @available postprocessing
 */" />
      </methods>
    </class>
    <class name="IloStateFunctionExpr">
      <methods>
        <method isConstructor="true" name="IloStateFunctionExpr"  type="IloStateFunctionExpr"  javaDoc="/**
 * @class
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 */" />
        <method name="getNumberOfSegments"  type="int"  javaDoc="/**
 * Returns the number of segments of a state function.
 *
 * @type int
 * @return The number of segments of the corresponding stepwise non-negative function. A segment is an interval [start, end) on which the value of the function is constant.
 * @available postprocessing
 */" />
        <method name="getSegmentStart"  type="int" argument1="int"  javaDoc="/**
 * Returns the start of a segment of a state function.
 * @param i   Segment position 
 * @type int
 * @return The start of the ith segment of the corresponding stepwise non-negative function.
 * @available postprocessing
 */" />
        <method name="getSegmentEnd"  type="int" argument1="int"  javaDoc="/**
 * Returns the end of a segment of a state function.
 * @param i   Segment position 
 * @type int
 * @return The end of the ith segment of the corresponding stepwise non-negative function.
 * @available postprocessing
 */" />
        <method name="getSegmentValue"  type="int" argument1="int"  javaDoc="/**
 * Returns the value of a segment of a state function.
 * @param i   Segment position 
 * @type int
 * @return The value of the ith segment of the corresponding stepwise non-negative function.
 * @available postprocessing
 */" />
        <method name="getValue"  type="int" argument1="int"  javaDoc="/**
 * Returns the value of a state function at a given point.
 * @param i A point
 * @type int
 * @return The value of the corresponding stepwise non-negative function at point &lt;code&gt;i&lt;/code&gt;.
 * @available postprocessing
 */" />
      </methods>
    </class>
    <class name="IloOplFile">
      <methods>
        <method isConstructor="true" name="IloOplFile"  type="IloOplFile" argument1="string"  javaDoc="/**
 * 
 * Creates an instance of a new &lt;code&gt;IloOplFile&lt;/code&gt; from a &lt;code&gt;path&lt;/code&gt;.
 * @param path The path of the file or directory; it can be an absolute path or not. 
 * For instance &quot;/home/work/&quot;, &quot;.&quot; or &quot;./..&quot;. 
 * @available flow control
 * @class
 * &lt;p&gt;This class creates an abstract representation of a file or directory. It can be used to list the contents of a directory, to check if a given file exists, or to check if a file is a hidden file.&lt;/p&gt;
 * &lt;p&gt;See the &lt;a href =&quot;intro.html&quot;&gt;Overview&lt;/a&gt; for a general presentation of the ILOG Script extensions for OPL.
 * &lt;/p&gt;
 * @example
 * execute {
 *   var path = &quot;.&quot;;
 *
 *   var directory = new IloOplFile(path); 
 *   
 *   if( !directory.exists ) {
 *     writeln( &quot;ERROR: Cannot find specified file&quot; );
 *   } else if (directory.isDirectory != true) {
 *     writeln( &quot;ERROR: Not a directory&quot; );
 *   } else {
 *     writeln( &quot;It is a directory&quot; + directory.name );
 *     var file = directory.getFirstFileName();
 *     // Print the content of the directory
 *     while ( file!=null ) {
 *       var entry = new IloOplFile(path + directory.separator + file);
 *       if (entry.isDirectory) {
 *         writeln( &quot;Dir  &quot; + entry.name );
 *       } else {
 *         writeln( &quot;File &quot; + entry.name );
 * }
 *       file = directory.getNextFileName();
 *     }
 *   }
 * }
 * 
 * @example {
 * This example parses the current directory &apos;.&apos; and lists its files and subdirectories.
 * After creating a new instance of  &lt;code&gt;IloOplFile(path)&lt;/code&gt;&#44; you should check that the path is valid
 * using the property &lt;code&gt;exists&lt;/code&gt; (&lt;code&gt;if (!directory.exists)&lt;/code&gt;).
 * This check must be done before you call any other method of &lt;code&gt;IloOplFile&lt;/code&gt;. 
 * Calling a method on an invalid &lt;code&gt;IloOplFile&lt;/code&gt; will throw an exception saying 
 * &quot;Cannot find the specified file&quot;.}
 *
 * @iterating Empty iteration.
 * @named Default behavior.  
 * @ilog.undocumented.jsFile
 */" />
        <method name="name" isProperty="true"  type="string"  javaDoc="/**
 * Returns the name of the file or directory denoted 
 * by this abstract pathname. Same as specified to the constructor.
 * @type string
 * @available flow control
 */" />
        <method name="exists" isProperty="true"  type="boolean"  javaDoc="/**
 * Returns &lt;code&gt;true&lt;/code&gt; if the file exists.
 * @type boolean
 * @available flow control
 */" />
        <method name="absolutePath" isProperty="true"  type="string"  javaDoc="/**
 * Returns the absolute pathname of this file or directory. 
 * If the path passed to the constructor is already absolute, it returns
 * &lt;code&gt;name&lt;/code&gt;. Otherwise, this pathname is resolved in a system-dependent way. 
 * On UNIX systems, a relative pathname is made absolute by resolving 
 * it against the current directory. On Microsoft Windows systems, 
 * a relative pathname is made absolute by resolving it against the 
 * current directory of the drive named by the pathname. 
 * @type string
 * @available flow control
 */" />
        <method name="isHidden" isProperty="true"  type="boolean"  javaDoc="/**
 * Returns &lt;code&gt;true&lt;/code&gt; if this file or directory is hidden. 
 * The exact definition of hidden is system-dependent. 
 * On UNIX systems, a file is considered to be hidden if its 
 * name begins with a period character (&apos;.&apos;). On Microsoft Windows systems, 
 * a file is considered to be hidden if it has been marked as such in the file system. 
 * @type boolean
 * @available flow control
 */" />
        <method name="isDirectory" isProperty="true"  type="boolean"  javaDoc="/**
 * Tests whether the file denoted by this abstract pathname is a directory. 
 *
 * @type boolean
 * @available flow control 
 * @return &lt;code&gt;true&lt;/code&gt; if and only if the file denoted by this abstract pathname exists and is a directory; &lt;code&gt;false&lt;/code&gt; otherwise.
 */" />
        <method name="separator" isProperty="true"  type="string"  javaDoc="/**
 * Returns a system-dependent default name-separator character.
 * The definition of separator is system dependent.
 * @type string
 * @available flow control
 */" />
        <method name="getFirstFileName"  type="string"  javaDoc="/**
 * Returns the name of the  first file or subdirectory in this directory.
 * If there is no file or subdirectory, it returns &lt;code&gt;null&lt;/code&gt;.
 * @type string
 * @available flow control
 * @return The name of the  first file or subdirectory in this directory. 
 */" />
        <method name="getNextFileName"  type="string"  javaDoc="/**
 * Returns the name of the next file or subdirectory in this directory,
 * or &lt;code&gt;null&lt;/code&gt; if there are no more files.
 * @type string
 * @available flow control
 * @return The name of the  next file or subdirectory in this directory.  
 */" />
      </methods>
    </class>
    <class name="IloObjective">
      <methods>
        <method isConstructor="true" name="IloObjective"  type="IloObjective"  javaDoc="/**
 * @class
 *
 * @example
 * dvar int x in 0..200;
 * 
 * minimize x;
 * subject to
 * {
 * x&gt;=10;
 * }
 * 
 * main
 * {   
 *  thisOplModel.generate();
 *  thisOplModel.getObjective().setCoef(thisOplModel.x,3);  
 *  cplex.solve();
 *  writeln(cplex.getObjValue());
 *  if (cplex.getObjValue()!=30) fail(); 
 * }
 * 
 * @iterating Default behavior.
 * @named Default behavior.
 *
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 */" />
        <method name="setCoef" argument1="dvar float" argument2="float"  javaDoc="/**
 * Changes the coefficient of a decision variable in the invoking objective.
 * This method is limited to objectives that use simple real linear expressions with no
 * aggregation. In other cases, use the method from the &lt;code&gt;IloCplex&lt;/code&gt; class. 
 *
 * @param dvar Decision variable.
 * @param coef The new linear coefficient.
 * @available all
 */" />
        <method name="solutionValue" isProperty="true"  type="float"  javaDoc="/**
 * Value in the current solution for the objective.
 * @type float
 * @available postprocessing
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloDiscreteDataCollection">
      <methods>
        <method isConstructor="true" name="IloDiscreteDataCollection"  type="IloDiscreteDataCollection"  javaDoc="/**
 * @class
 *
 * @example {}
 * {int} s={1,2};
 *
 * execute
 * {
 *  writeln(s.size, &quot; is the size of &quot;,s); 
 *  s.add(4);
 *  writeln(s.size, &quot; is the size of &quot;,s); 
 * }
 * @example {After execution&#44; the Scripting log shows:}
 * 2 is the size of  {1 2}
 * 3 is the size of  {1 2 4}
 *
 * @opl-type {int}
 * @opl-type {float}
 * @opl-type {string}
 *
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 *
 * @named Default behavior
 * @iterating Iterates on the items of a collection
 */" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available all
 */" />
        <method name="size" isProperty="true"  type="int"  javaDoc="/**
 * The number of items in this collection.
 * @type int
 * @available all
 */" />
        <method name="add"  type="IloConstraint" argument1="IloObject"  javaDoc="/**
 * Adds an item to this collection.
 *
 * @param item The item to add to this collection.
 * @available all
 */" />
        <method name="remove" argument1="IloObject"  javaDoc="/**
 * Removes an item of this collection. Does nothing if the expected item doesn&apos;t exist.
 *
 * @param item The item to remove.
 * @available all
 */" />
        <method name="addAll" argument1="IloDiscreteDataCollection"  javaDoc="/**
 * Adds several items to this collection using built-in arrays.
 *
 * @example
 * {int} s={}
 *
 * execute {
 *  writeln(s.size, &quot; is the size of &quot;,s); 
 *  s.addAll(new Array(1,2,3,4));
 *  writeln(s.size, &quot; is the size of &quot;,s); 
 * }
 *
 * @param itemArray An array with items to add to this collection.
 * @available all
 */" />
        <method name="contains"  type="boolean" argument1="IloObject"  javaDoc="/**
 * Returns whether the item is contained in this collection.
 *
 * @param item The item to look for in this collection.
 * @return &lt;code&gt;true&lt;/code&gt; if the item is in the collection.
 * @type boolean
 * @available all
 */" />
        <method name="isSorted"  type="boolean"  javaDoc="/**
 * Returns whether the collection is sorted or not.
 *
 * @return &lt;code&gt;true&lt;/code&gt; if the collection is sorted.
 * @type boolean
 * @available all
 */" />
        <method name="isReversed"  type="boolean"  javaDoc="/**
 * Returns whether the collection is reversed or not.
 *
 * @return &lt;code&gt;true&lt;/code&gt; if the collection is reversed.
 * @type boolean
 * @available all
 */" />
        <method name="isOrdered"  type="boolean"  javaDoc="/**
 * Returns whether the collection is ordered or not.
 *
 * @return &lt;code&gt;true&lt;/code&gt; if the collection is ordered.
 * @type boolean
 * @available all
 */" />
        <method name="clearAllCaches"  javaDoc="/**
 * @ignore
 *
 * Clears all internal caches for this collection.
 * @available all
 */" />
        <method name="clear"  type="void"  javaDoc="/**
 * @ignore
 *
 * Clears all internal caches for this collection.
 * @available all
 */" />
        <method name="importSet" argument1="IloObject"  javaDoc="/**
* Imports an external collection.
*
* @param item The item to import.
* @available all
*/" />
      </methods>
    </class>
    <class name="IloCplex">
      <methods>
        <method isConstructor="true" name="IloCplex"  type="IloCplex"  javaDoc="/**
 *
 * @class
 *
 * &lt;p&gt;Uses CPLEX parameter names as property names to change their value. For example, the
 * following code line:&lt;/p&gt;
 * &lt;pre class=&quot;ShortCode&quot;&gt;
 *   cplex.tilim = 13;
 * &lt;/pre&gt;
 * changes the time limit.
 *
 *
 * @example
 * dvar int x[1..20] in 0..40;
 * 
 * maximize sum(i in 1..20) x[i];
 * 
 * subject to {
 *   x[1]==0; 
 *   forall(i in 1..19) x[i+1]-x[i]&lt;=2;  
 * }
 * 
 * execute {
 *   writeln(cplex.getObjValue());  
 * }
 * 
 * @extends IloObject
 * @available flow control
 * @iterating Iterates on the names of the CPLEX parameters, the values of which are different from their default.
 * @named Default behavior.
 * @ilog.undocumented.jsFile
 */" />
        <method name="setCoef" argument2="dvar float" argument3="float" argument1="constraint"  javaDoc="/**
 * Sets the coefficient of a decision variable in the constraint.
 *
 * @param ct Constraint (must be a range).
 * @param dvar The decision variable.
 * @param coef The new coefficient.
 * @available flow control
 */" />
        <method name="clearCuts"  type="void"  javaDoc="/**
* Deletes all cuts that were previously added to the invoking &lt;code&gt;IloCplex&lt;/code&gt; object 
* with the methods &lt;code&gt;addCut&lt;/code&gt; and &lt;code&gt;addCuts&lt;/code&gt;.
* @type void
* @available postprocessing
* @available flow control
*/" />
        <method name="clearLazyConstraints"  type="void"  javaDoc="/**
* Deletes all lazy constraints added to the invoking &lt;code&gt;IloCplex&lt;/code&gt; object 
* with the methods &lt;code&gt;addLazyConstraint&lt;/code&gt; and &lt;code&gt;addLazyConstraints&lt;/code&gt;.
* This method is equivalent to &lt;code&gt;clearCuts&lt;/code&gt;. 
* For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
* @type void
* @available flow control
*/" />
        <method name="clearUserCuts"  type="void"  javaDoc="/**
* Deletes all user cuts that were previously added to the invoking &lt;code&gt;IloCplex&lt;/code&gt; object 
* with the methods &lt;code&gt;addUserCut&lt;/code&gt; and &lt;code&gt;addUserCuts&lt;/code&gt;.
* For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
* @type void
* @available flow control
*/" />
        <method name="getNbarrierIterations"  type="int"  javaDoc="/**
* Returns the number of barrier iterations from the last solve.
*
* @type int
* @available flow control
*/" />
        <method name="getNcrossDExch"  type="int"  javaDoc="/**
* Returns the number of dual exchange operations in the crossover of the last call
* to the &lt;code&gt;solve&lt;/code&gt; method, if barrier with crossover was used for solving an LP or QP.
*
* @type int
* @available flow control
*/" />
        <method name="getNcrossDPush"  type="int"  javaDoc="/**
* Returns the number of dual push operations in the crossover of the last call to
* the &lt;code&gt;solve&lt;/code&gt; method, if barrier with crossover was used for solving an LP or QP.
*
* @type int
* @available flow control
*/" />
        <method name="getNcrossPExch"  type="int"  javaDoc="/**
* Returns the number of primal exchange operations in the crossover of the last call of 
* the &lt;code&gt;solve&lt;/code&gt; method, if barrier with crossover was used for solving an LP or QP.
* @type int
* @available flow control
*/" />
        <method name="getNcrossPPush"  type="int"  javaDoc="/**
* Returns the number of primal push operations in the crossover of the last call of
* the &lt;code&gt;solve&lt;/code&gt; method, if barrier with crossover was used for solving an LP or QP. 
*
* @type int
* @available flow control
*/" />
        <method name="getNdualSuperbasics"  type="int"  javaDoc="/**
* Returns the number of dual superbasic variables in the current solution of 
* the invoking &lt;code&gt;IloCplex&lt;/code&gt; object.
*
* @type int
* @available flow control
*/" />
        <method name="getNphaseOneIterations"  type="int"  javaDoc="/**
* If a simplex method was used for solving a continuous model, 
* this method returns the number of iterations in phase one of the last call to the &lt;code&gt;solve&lt;/code&gt; method.
*
* @type int
* @available flow control
*/" />
        <method name="getNprimalSuperbasics"  type="int"  javaDoc="/**
* Returns the number of primal superbasic variables in the current solution 
* of the invoking &lt;code&gt;IloCplex&lt;/code&gt; object.
*
* @type int
* @available flow control
*/" />
        <method name="getNsemiContVars"  type="int"  javaDoc="/**
* Returns the number of semicontinuous variables in the matrix representation 
* of the active model in the invoking &lt;code&gt;IloCplex&lt;/code&gt; object.
*
* @type int
* @available flow control
*/" />
        <method name="getNsemiIntVars"  type="int"  javaDoc="/**
* Returns the number of semi-integer variables in the matrix representation 
* of the active model in the invoking &lt;code&gt;IloCplex&lt;/code&gt; object.
*
* @type int
* @available flow control
*/" />
        <method name="getNsiftingIterations"  type="int"  javaDoc="/**
* Returns the number of sifting iterations performed for solving the last LP with algorithm type
* &lt;code&gt;Sifting&lt;/code&gt;, or, equivalently, the number of work LPs that have been solved for it.
*
* @type int
* @available flow control
*/" />
        <method name="getNsiftingPhaseOneIterations"  type="int"  javaDoc="/**
* Returns the number of sifting iterations performed for solving the last LP with algorithm type
* &lt;code&gt;Sifting&lt;/code&gt; in order to achieve primal feasibility.
*
* @type int
* @available flow control
*/" />
        <method name="getNumCores"  type="int"  javaDoc="/**
* Returns the number of logical cores on the platform where CPLEX is currently running.
*
* @type int
* @available flow control
*/" />
        <method name="getCutoff"  type="int"  javaDoc="/**
* Returns the MIP cutoff value being used during the MIP optimization. In a minimization problem, 
* all nodes are pruned that have an optimal solution value of the continuous relaxation that is 
* larger than the current cutoff value. The cutoff is updated with the incumbent. 
* If the invoking &lt;code&gt;IloCplex&lt;/code&gt; object is an LP or QP, 
* this method returns &lt;code&gt;+IloInfinity&lt;/code&gt; or &lt;code&gt;-IloInfinity&lt;/code&gt;, depending on the optimization sense.
*
* @type int
* @available flow control
*/" />
        <method name="getIncumbentNode"  type="int"  javaDoc="/**
* Returns the node number where the current incumbent was found. 
* If the invoking &lt;code&gt;IloCplex&lt;/code&gt; object is an LP or a QP, this method returns 0 (zero).
*
* @type int
* @available flow control
*/" />
        <method name="isDualFeasible"  type="boolean"  javaDoc="/**
* Returns &lt;code&gt;true&lt;/code&gt; if a dual feasible solution is recorded in the 
* invoking &lt;code&gt;IloCplex&lt;/code&gt; object and can be queried.
*
* @type boolean
* @available flow control
*/" />
        <method name="isPrimalFeasible"  type="boolean"  javaDoc="/**
* Returns &lt;code&gt;true&lt;/code&gt; if a primal feasible solution is recorded in the 
* invoking &lt;code&gt;IloCplex&lt;/code&gt; object and can be queried.
*
* @type boolean
* @available flow control
*/" />
        <method name="isQC"  type="boolean"  javaDoc="/**
* Returns &lt;code&gt;true&lt;/code&gt; if the invoking algorithm has extracted a model 
* that is quadratically constrained. Otherwise, it returns &lt;code&gt;false&lt;/code&gt;. 
* For an explanation of quadratically constrained see the document: 
* &lt;i&gt;User&apos;s Manual for CPLEX &gt; Continuous optimization &gt; Solving problems with quadratic constraints (QCP) &gt;
* Identifying a quadratically constrained program (QCP) &gt; Characteristics of a quadratically constrained program&lt;/i&gt;
*
* @type boolean
* @available flow control
*/" />
        <method name="isQO"  type="boolean"  javaDoc="/**
* Returns &lt;code&gt;true&lt;/code&gt; if the invoking algorithm has extracted a model 
* that has quadratic objective function terms. Otherwise, it returns &lt;code&gt;false&lt;/code&gt;.
* For more information, see the document: 
* &lt;i&gt;User&apos;s Manual for CPLEX &gt; Continuous optimization &gt; Solving problems with a quadratic objective (QP)&lt;/i&gt;
* @type boolean
* @available flow control
*/" />
        <method name="getSolnPoolNreplaced"  type="int"  javaDoc="/**
* Accesses the number of solutions that have been replaced 
* according to the solution pool replacement strategy.
*
* @type int
* @available flow control
*/" />
        <method name="getSolnPoolNsolns"  type="int"  javaDoc="/**
* Accesses the number of solutions currently in the solution pool.
*
* @type int
* @available flow control
*/" />
        <method name="getSolnPoolMeanObjValue"  type="int"  javaDoc="/**
* Computes the mean of the objective values of the solutions currently in the solution pool.
*
* @type int
* @available flow control
*/" />
        <method name="addCut" argument1="constraint"  javaDoc="/**
* Adds the constraint &lt;code&gt;ct&lt;/code&gt; as a cut to the invoking &lt;code&gt;IloCplex&lt;/code&gt; object. 
* The cut is not extracted in the same way as the regular constraints in a model, 
* but is only copied when the method &lt;code&gt;addCut&lt;/code&gt; is invoked. 
* Thus, &lt;code&gt;ct&lt;/code&gt; may be deleted or modified after &lt;code&gt;addCut&lt;/code&gt; has been called 
* and notification of the change will not be sent to the invoking &lt;code&gt;IloCplex&lt;/code&gt; object.
*
* When columns are deleted from the extracted model, all cuts are deleted as well 
* and need to be re-extracted if they should be considered. 
* Cuts are not part of the root problem, but are considered on an as-needed basis. 
* A solution computed by &lt;code&gt;IloCplex&lt;/code&gt; is guaranteed to satisfy all cuts added with this method.
*
* @param ct A constraint.
* @available all
*/" />
        <method name="addCuts" argument1="arrayof_constraint"  javaDoc="/**
* Adds the constraints in the array &lt;code&gt;cts&lt;/code&gt; as cuts to the invoking &lt;code&gt;IloCplex&lt;/code&gt; object. 
* Everything said for &lt;code&gt;addCut&lt;/code&gt; applies equally to each of the cuts given in the array &lt;code&gt;cts&lt;/code&gt;.
*
* @param cts An array of constraints.
* @available all
*/" />
        <method name="addLazyConstraint" argument1="constraint"  javaDoc="/**
* Adds &lt;code&gt;ct&lt;/code&gt; as a lazy constraint to the invoking &lt;code&gt;IloCplex&lt;/code&gt; object. 
* For more information on &lt;code&gt;addLazyConstraint&lt;/code&gt;, 
* see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
*
* @param ct A constraint.
* @available all
*/" />
        <method name="addLazyConstraints" argument1="arrayof_constraint"  javaDoc="/**
* Adds &lt;code&gt;cts&lt;/code&gt; as an array of lazy constraints to the invoking &lt;code&gt;IloCplex&lt;/code&gt; object. 
* For more information on &lt;code&gt;addLazyConstraints&lt;/code&gt;, 
* see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
*
* @param cts An array of constraints.
* @available all
*/" />
        <method name="addUserCut" argument1="constraint"  javaDoc="/**
* Adds a constraint &lt;code&gt;ct&lt;/code&gt; as a user cut to the invoking &lt;code&gt;IloCplex&lt;/code&gt; object. 
* The constraint &lt;code&gt;ct&lt;/code&gt; is copied into the user cut pool; the &lt;code&gt;ct&lt;/code&gt; itself 
* is not part of the pool, so changes to &lt;code&gt;ct&lt;/code&gt; after it has been copied into the 
* user cut pool will not affect the user cut pool.
* For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
*
* @param ct A constraint.
* @available all
*/" />
        <method name="addUserCuts" argument1="arrayof_constraint"  javaDoc="/**
* Adds an array of constraints &lt;code&gt;cts&lt;/code&gt; as user cuts to the invoking &lt;code&gt;IloCplex&lt;/code&gt; object. 
* Everything said for &lt;code&gt;addUserCut&lt;/code&gt; applies to each of the user cuts given in the array &lt;code&gt;cts&lt;/code&gt;.
* For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
*
* @param cts An array of constraints.
* @available all
*/" />
        <method name="delDirection" argument1="dvar float"  javaDoc="/**
* Removes any existing branching direction assignment from the variable &lt;code&gt;dvar&lt;/code&gt;.
*
* @param dvar A variable.
* @available all
*/" />
        <method name="delPriority" argument1="dvar float"  javaDoc="/**
* Removes any existing priority order assignment from the variable &lt;code&gt;dvar&lt;/code&gt;.
*
* @param dvar A variable.
* @available all
*/" />
        <method name="getAX"  type="float" argument1="range float"  javaDoc="/**
* Computes A times X, where A is the corresponding LP constraint matrix.
* Returns the value of the expression of the constraint range, or, equivalently, its activity level, 
* for the current solution of the invoking &lt;code&gt;IloCplex&lt;/code&gt; object. The range must be part of the extracted model.
*
* @param range A range.
* @return a number
* @type float
* @available all
*/" />
        <method name="getLb"  type="float" argument1="range float"  javaDoc="/**
* Queries the lower bound of the ranged constraints.
*
* @param range A range of constraints.
* @return The lower bound of the ranged constraints.
* @type float
* @available all
*/" />
        <method name="getUb"  type="float" argument1="range float"  javaDoc="/**
* Queries the upper bound of the ranged constraints.
*
* @param range A range of constraints.
* @return The upper bound of the ranged constraints.
* @type float
* @available all
*/" />
        <method name="setLb" argument1="range float" argument2="float"  javaDoc="/**
* Sets the lower bound of the ranged constraints.
*
* @param range A range of constraints.
* @param lb A lower bound.
* @available all
*/" />
        <method name="setUb" argument1="range float" argument2="float"  javaDoc="/**
* Sets the upper bound of the ranged constraints.
*
* @param range A range of constraints.
* @param ub An upper bound.
* @available all
*/" />
        <method name="getInfeasibility" argument1="dvar float"  javaDoc="/**
* Returns the infeasibility of the current solution for the constraint &lt;code&gt;ct&lt;/code&gt;. 
* The infeasibility value is 0 (zero) if the constraint is satisfied. 
* More specifically, for a range with finite lower bound and upper bound, 
* if the infeasibility value is negative, it specifies the amount by which the lower bound 
* of the range must be changed; if the value is positive, it specifies the amount by which 
* the upper bound of the range must be changed. 
*
* @param ct A constraint.
* @return a number
* @available all
*/" />
        <method name="delSolnPoolSoln"  type="void" argument2="int" argument1="int"  javaDoc="/**
* Deletes a range of solutions from the solution pool and renumbers 
* the indices of the remaining solutions in the pool.
*
* @param first A start index.
* @param end An end index 
* @type void
* @available all
*/" />
        <method name="basicPresolve" argument4="arrayof_range float" argument1="arrayof_dvar float" argument5="arrayof_IloBool" argument2="arrayof_float" argument3="arrayof_float"  javaDoc="/**
*See the reference manual for IloCplex.
*
* @param dvars An array of variables.
* @available all
*/" />
        <method name="delDirections" argument1="arrayof_dvar float"  javaDoc="/**
* Removes any existing branching direction assignments from all variables in the array &lt;code&gt;dvars&lt;/code&gt;.
*
* @param dvars An array of variables.
* @available all
*/" />
        <method name="delPriorities" argument1="arrayof_dvar float"  javaDoc="/**
* Removes any existing priority order assignments from all variables in the array &lt;code&gt;dvars&lt;/code&gt;.
*
* @param dvars An array of variables.
* @available all
*/" />
        <method name="protectVariables" argument1="arrayof_dvar float"  javaDoc="/**
* Specifies an array of decision variables that should not be substituted out of the problem. 
* If presolve can fix a variable to a value, it is removed, even if it is specified in the protected list.
* For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;. 
*
* @param dvars An array of variables.
* @available all
*/" />
        <method name="getPriorities" argument2="arrayof_dvar float" argument1="arrayof_float"  javaDoc="/**
* Returns query branch priorities previously assigned to variables listed in &lt;code&gt;dvars&lt;/code&gt;
* with the method &lt;code&gt;setPriority&lt;/code&gt; or &lt;code&gt;setPriorities&lt;/code&gt;. When the function returns, 
* &lt;code&gt;priorities[i]&lt;/code&gt; will contain the priority value assigned for variable &lt;code&gt;dvars[i]&lt;/code&gt;. 
* If no priority has been assigned to &lt;code&gt;dvars[i]&lt;/code&gt;, &lt;code&gt;priorities[i]&lt;/code&gt; will contain 0 (zero).
*
* @param priorities An array of priorities
* @param dvars An array of variables.
* @available all
*/" />
        <method name="qpIndefCertificate" argument1="arrayof_dvar float" argument2="arrayof_float"  javaDoc="/**
* Computes assignments (returned in array vals) to all variables (returned in array dvars) 
* such that the quadratic term of the objective function evaluates to 
* a negative value to prove the indefiniteness.
* For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;. 
*
* @param dvars An array of variables
* @param vals An array of floats
* @available all
*/" />
        <method name="setPriorities" argument1="arrayof_dvar float" argument2="arrayof_float"  javaDoc="/**
* Sets the priority order for all variables in the array &lt;code&gt;dvars&lt;/code&gt; 
* to the corresponding value in the array &lt;code&gt;priorities&lt;/code&gt;.
* For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;. 
*
* @param dvars An array of variables
* @param priorities An array of floats
* @available all
*/" />
        <method name="dualFarkas"  type="float" argument2="arrayof_float" argument1="arrayof_constraint"  javaDoc="/**
* Returns a Farkas proof of infeasibility for the active LP model 
* after it has been proven to be infeasible by one of the simplex optimizers.
* For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;..
*
* @param cts An array of constraints
* @param values An array.
* @return a number
* @type float 
* @available all
*/" />
        <method name="addDiversityFilter" argument6="string" argument3="arrayof_dvar float" argument4="arrayof_float" argument5="arrayof_float" argument1="float" argument2="float"  javaDoc="/**
* Creates and installs a named diversity filter for the designated decision variables
* with the specified lower and upper cutoff values, reference values, and weights.
* For more information on &lt;code&gt;addDiversityFilter&lt;/code&gt;, 
* see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
*
* @param lb A lower bound.
* @param ub An upper bound.
* @param dvars An array with decision variables. Use built-in arrays.
* @param weights An array with weights. Use built-in arrays.
* @param refs An array with reference values. Use built-in arrays.
* @param name Optional: The name of the filter
* @available all
*/" />
        <method name="populate"  type="boolean"  javaDoc="/**
 * Populates the solution pool.
 * For more information on &lt;code&gt;populate&lt;/code&gt;, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the 
 * &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 * 
 * @type boolean
 * @return &lt;code&gt;true&lt;/code&gt; if the populate has been successful.
 * @available flow control
 */" />
        <method name="getCplexStatus"  type="int"  javaDoc="/**
 * Returns the IBM ILOG CPLEX status.
 * 
 * See the section &lt;b&gt;CPLEX solution status&lt;/b&gt; in &lt;i&gt;Language User&apos;s Manual &gt; 
 * ILOG Script for OPL &gt; Introduction to scripting &gt; Preprocessing and postprocessing 
 * &gt; Changing option values &gt; Changing CPLEX parameters&lt;/i&gt; for details of
 * the solution status codes.
 *
 * See also the section &lt;em&gt;Interpreting Solution Statistics&lt;/em&gt;
 * in the &lt;em&gt;IBM ILOG CPLEX User&apos;s Manual&lt;/em&gt; for more information about a status associated
 * with infeasibility or unboundedness.
 *
 * @type int
 * @return The IBM ILOG CPLEX status.
 * @available flow control
 * @available postprocessing
 */" />
        <method name="getDirection"  type="string" argument1="dvar float"  javaDoc="/**
 * Gets the branching direction of a decision variable.
 *
 * @type string
 * @param dvar Decision variable.
 * @return The branching direction,
 * one of &lt;code&gt;&quot;BranchDown&quot;, &quot;BranchGlobal&quot;, &quot;BranchUp&quot;&lt;/code&gt;.
 * @available all
 */" />
        <method name="setDirection" argument1="dvar float" argument2="string"  javaDoc="/**
 * Defines the branching direction of a decision variable.
 *
 * @param dvar Decision variable.
 * @param direction The branching direction,
 * one of &lt;code&gt;&quot;BranchDown&quot;, &quot;BranchGlobal&quot;, &quot;BranchUp&quot;&lt;/code&gt;.
 * @available all
 */" />
        <method name="clearModel"  javaDoc="/**
 * Resets CPLEX to accept another CPLEX model.
 *
 * @available flow control
 */" />
        <method name="exportModel" argument1="string"  javaDoc="/**
 * Exports the CPLEX model to a file.
 * The format depends on the extension of the file name passed (.lp, for example).
 * Relative paths are resolved with respect to the current model file.
 * For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 *
 * @param path Path of the file to which the model will be exported.
 * @available flow control
 */" />
        <method name="importModel" argument1="string"  javaDoc="/**
 * Imports the CPLEX model from a file.
 * The format depends on the extension of the file name passed: .lp, etc.
 * Relative paths are resolved with respect to the current model file.
 * For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 *
 * @param path Path to the file from which the model will be imported.
 * @available flow control
 */" />
        <method name="readAnnotations" argument1="string"  javaDoc="/**
 * Reads annotations from the file with the specified name
 * and installs them in the &lt;code&gt;IloCplex&lt;/code&gt; object.
 * This method is experimental.
 *
 * @param path Path to the file.
 * @available flow control
 */" />
        <method name="writeAnnotations" argument1="string"  javaDoc="/**
 * Writes all annotations of the &lt;code&gt;IloCplex&lt;/code&gt; object to the file with
 * the specified name.
 * This method is experimental.
 * @param path Path to the file.
 * @available flow control
 */" />
        <method name="writeBendersAnnotation" argument1="string"  javaDoc="/**
 * Writes the annotation that CPLEX would generate automatically for Benders
 * decomposition to a file with the specified name.
 * This method is experimental.
 * @param path Path to the file.
 * @available flow control
 */" />
        <method name="getVersion"  javaDoc="/**
 * This method returns a string specifying the version of
 * CPLEX.
 * This method is experimental.
 * @available flow control
 * @return a string
 */" />
        <method name="newNumAnnotation" argument1="string" argument2="value"  javaDoc="/**
 * Creates a new annotation of type IloNum for the
 * specified name and assigns the specified default value to 
 * all modeling objects in the current IloCplex object.  
 * This method is experimental.
 * @param name Name of the annotation.
 * @param value optional, default value, 0 otherwise.
 * @available flow control
 */" />
        <method name="newLongAnnotation" argument1="string" argument2="value"  javaDoc="/**
 * Creates a new annotation of type IloInt for the
 * specified name and assigns the specified default value to 
 * all modeling objects in the current IloCplex object.  
 * This method is experimental.
 * @param name Name of the annotation.
 * @param value optional, default value, 0 otherwise.
 * @available flow control
 */" />
        <method name="delNumAnnotation" argument1="string"  javaDoc="/**
 * Deletes the specified annotation.
 * This method is experimental.
 * @param name Name of the annotation.
 * @available flow control
 */" />
        <method name="delLongAnnotation" argument1="string"  javaDoc="/**
 * Deletes the specified annotation.
 * This method is experimental.
 * @param name Name of the annotation.
 * @available flow control
 */" />
        <method name="getNumAnnotation" argument1="string" argument2="extr"  javaDoc="/**
 * Queries the annotation value assigned to the variable or constraint 
 * by the specified annotation.
 * This method is experimental.
 * @param name Name of the annotation.
 * @param extr a variable or a constraint.
 * @return the value
 * @available flow control
 */" />
        <method name="getLongAnnotation" argument1="string" argument2="extr"  javaDoc="/**
 * Queries the annotation value assigned to the variable or constraint 
 * by the specified annotation.
 * This method is experimental.
 * @param name Name of the annotation.
 * @param extr a variable or a constraint.
 * @return the value
 * @available flow control
 */" />
        <method name="getLongAnnotations" argument1="string" argument2="arr"  javaDoc="/**
 * Queries the annotation value assigned to the variables or constraints 
 * by the specified annotation.
 * This method is experimental.
 * @param name Name of the annotation.
 * @param arr an array of variables or constraints.
 * @return the values
 * @available flow control
 */" />
        <method name="getNumAnnotations" argument1="string" argument2="arr"  javaDoc="/**
 * Queries the annotation value assigned to the variables or constraints 
 * by the specified annotation.
 * This method is experimental.
 * @param name Name of the annotation.
 * @param arr an array of variables or constraints.
 * @return the values
 * @available flow control
 */" />
        <method name="hasNumAnnotation"  javaDoc="/**
 * Queries whether an IloNum-valued annotation of the
 * specified name is available in the IloCplex object.  
 * This method is experimental.
 * @available flow control
 */" />
        <method name="hasLongAnnotation"  javaDoc="/**
 * Queries whether an IloInt-valued annotation of the
 * specified name is available in the IloCplex object.  
 * This method is experimental.
 * @available flow control
 */" />
        <method name="numNumAnnotations"  javaDoc="/** 
 * Queries the number of annotations of type IloNum.
 * This method is experimental.
 * @available flow control
 */" />
        <method name="numLongAnnotations"  javaDoc="/** 
 * Queries the number of annotations of type IloInt.
 * This method is experimental.
 * @available flow control
 */" />
        <method name="setNumAnnotation" argument1="string" argument3="value" argument2="extr"  javaDoc="/**
 * Assigns value as the value of the annotation 
 * of the variable or constraint for the specified annotation.
 * This method is experimental.
 * @param name Name of the annotation.
 * @param extr a variable or a constraint.
 * @param value value to be set.
 * @available flow control
 */" />
        <method name="setNumAnnotations" argument1="string" argument3="arrayof_float" argument2="extrs"  javaDoc="/**
 * Assigns values as the values of the annotation 
 * of the variables or constraints for the specified annotation.
 * This method is experimental.
 * @param name Name of the annotation.
 * @param extrs an array of variables or constraints.
 * @param value an array of values to be set.
 * @available flow control
 */" />
        <method name="setLongAnnotation" argument1="string" argument3="value" argument2="extr"  javaDoc="/**
 * Assigns value as the value of the annotation 
 * of the variable or constraint for the specified annotation.
 * This method is experimental.
 * @param name Name of the annotation.
 * @param extr a variable or a constraint.
 * @param value value to be set.
 * @available flow control
 */" />
        <method name="setLongAnnotations" argument1="string" argument3="arrayof_float" argument2="extrs"  javaDoc="/**
 * Assigns values as the values of the annotation 
 * of the variables or constraints for the specified annotation.
 * This method is experimental.
 * @param name Name of the annotation.
 * @param extrs an array of variables or constraints.
 * @param value an array of values to be set.
 * @available flow control
 */" />
        <method name="writeBasis" argument1="string"  javaDoc="/**
* Writes the current CPLEX basis to the specified file.
* By convention, the file extension is &lt;code&gt;.bas&lt;/code&gt;. 
* The BAS file format is documented in the reference manual &lt;i&gt;CPLEX File Formats&lt;/i&gt;. 
*
* @param file File to which the basis will be exported.
* @available flow control
*/" />
        <method name="readBasis" argument1="string"  javaDoc="/**
* Reads the CPLEX basis from a file.
* See the class IloCplex in
* IDE and OPL - OPL Interfaces - C++ interface reference manual - optim.cplex.cpp - Classes
*
* @param file File from which the basis will be imported.
* @available flow control
*/" />
        <method name="getBestObjValue"  type="float"  javaDoc="/**
* Accesses the currently best known bound on the optimal solution value of the problem. 
* For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
*
* @type float
* @return The currently best known bound on the optimal solution value of the problem.
* @available postprocessing
* @available flow control
*/" />
        <method name="getObjValue"  type="float" argument1="int"  javaDoc="/**
 * Accesses the objective value of the current solution or the solution identifier from the solution pool.
 *
 * @type float
 * @param i optional The identifier of the solution.
 * @return The objective value of the solution identifier or of the current solution if the identifier is not specified.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getNnodesLeft"  type="int"  javaDoc="/**
 * Accesses the number of branch-and-cut nodes that remain to be processed in the current solution.
 * If the invoking CPLEX object is not a MIP, this method returns 0.
 *
 * @type int
 * @return The number of branch-and-cut nodes that remain to be processed in the current solution.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="addRange"  type="IloConstraint" argument1="float" argument2="float"  javaDoc="/**
 * @ignore
 * The number of branch-and-cut nodes that remain to be processed in the current solution.
 *If the invoking cplex object is not a MIP, the method returns 0.
 *
 * @type IloConstraint
 * @return The new range.
 * @param lb The lower bound.
 * @param ub The upper bound.
 * @available flow control
 */" />
        <method name="setObjCoef" argument1="dvar float" argument2="float"  javaDoc="/**
 * Sets the coefficient of a decision variable in the objective expression.
 *
 * @param dvar The decision variable.
 * @param coef The new coefficient.
 * @available flow control
 */" />
        <method name="getNrows"  type="int"  javaDoc="/**
 * Accesses the number of rows extracted for the invoking algorithm.
 * For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 *
 * @type int
 * @return The number of rows.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getNcols"  type="int"  javaDoc="/**
 * Accesses the number of columns extracted for the invoking algorithm. 
 * For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 *
 * @type int
 * @return The number of columns.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getNNZs"  type="int"  javaDoc="/**
 * Accesses the number of nonzeros extracted to the constraint matrix A of the invoking algorithm.
 *
 * @type int
 * @return The number of nonzero values.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="addRangeFilter" argument5="string" argument3="arrayof_dvar float" argument4="arrayof_float" argument1="float" argument2="float"  javaDoc="/**
 * Creates a named range filter, using the specified lower bound, upper bound, decision variables, and weights. 
 * Adds the filter to the solution pool of the invoking model, and returns the index of the filter.
 * For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 *
 * @param lb A lower bound.
 * @param ub An upper bound.
 * @param dvars An array with decision variables. Use built-in arrays.
 * @param vals An array with values. Use built-in arrays.
 * @param name Optional: The name of the filter
 * @available all
 */" />
        <method name="getCplexTime"  type="float"  javaDoc="/**
 * Returns a time stamp.
 * For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 *
 * @type float
 * @return The time stamp.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getMIPRelativeGap"  type="float"  javaDoc="/**
 * Accesses the relative objective gap for a MIP optimization
 * For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 * @see IloCplex#isMIP
 * @type float
 * @return The relative objective gap.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="isMIP"  type="boolean"  javaDoc="/**
 * This method returns &lt;code&gt;true&lt;/code&gt; if the invoking algorithm 
 * has extracted a model that is a MIP 
 * (mixed-integer programming problem) and &lt;code&gt;false&lt;/code&gt; otherwise.
 * Methods for accessing duals and reduced cost basis work only if the model is not a MIP.
 *
 * @return &lt;code&gt;true&lt;/code&gt; if it is a MIP model.
 * @type boolean
 * @return The relative objective gap.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getNintVars"  type="int"  javaDoc="/**
 * Returns the number of integer variables in the matrix representation of 
 * the active model in the invoking &lt;code&gt;IloCplex&lt;/code&gt; object.
 *
 * @type int
 * @return The number of integer variables.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getNbinVars"  type="int"  javaDoc="/**
 * Returns the number of binary variables in the matrix representation of 
 * the active model in the invoking &lt;code&gt;IloCplex&lt;/code&gt; object.
 *
 * @type int
 * @return The number of binary variables.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getNQCs"  type="int"  javaDoc="/**
 * Returns the number of quadratic constraints 
 * extracted from the active model for the invoking algorithm.
 * This number may be different from the total number of constraints 
 * in the active model because linear constraints are not accounted for in this function
 *
 * @type int
 * @return The number of quadratic constraints.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getNSOSs"  type="int"  javaDoc="/**
 * Returns the number of SOSs extracted for the invoking algorithm.
 * There may be differences in the number returned by this function and the number of numeric variables 
 * (that is, instances of the class IloNumVar, and so forth) in the model that is extracted 
 * because piecewise linear functions are extracted as a set of SOSs.
 *
 * @type int
 * @return The number of SOSs.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getDetTime"  type="float"  javaDoc="/**
 * Returns a deterministic time stamp in ticks.
 * &lt;p&gt;
 * To measure elapsed deterministic time in ticks between 
 * a starting point and ending point of an operation, 
 * take the deterministic time stamp at the starting point; 
 * take the deterministic time stamp at the ending point; 
 * subtract the starting deterministic time stamp from 
 * the ending deterministic time stamp. &lt;/p&gt;
 * &lt;p&gt;The absolute value of the deterministic time stamp is not meaningful.&lt;/p&gt;
 *
 * @type float
 * @return The deterministic time stamp.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getSolvedTime"  type="float"  javaDoc="/**
 * Returns the time it took to solve. It is the difference between the time 
 * stamp before the call to solve and the time stamp after the solve.
 * For more information, see &lt;code&gt;IloCplex::getCplexTime&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 *
 * @type float
 * @return The time it took to solve.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getNMIPStarts"  type="int"  javaDoc="/**
 * Returns the number of MIP starts associated with the current problem.
 *
 * @type int
 * @return The number of MIP starts.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="addMIPStart" argument4="string" argument1="arrayof_dvar float" argument2="arrayof_float" argument3="string"  javaDoc="/**
 * Adds a named MIP start, with the specified level of effort
 * defined by the specified variables, and their corresponding values,
 * to the current problem.
 * For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 *
 * @param dvars An array with decision variables. Use built-in arrays.
 * @param values An array with values. Use built-in arrays.
 * @param effort Optional: level of effort.
 * @param name Optional: the name of the filter
 * @available flow control
 */" />
        <method name="changeMIPStart" argument2="arrayof_dvar float" argument3="arrayof_float" argument4="string" argument1="int"  javaDoc="/**
 * Changes the MIP start, designated by its index, by
 * assigning corresponding values to the designated variables,
 * and by associating the specified level of effort.
 * For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 *
 * @param mipstartindex MIP start index.
 * @param dvars An array with decision variables. Use built-in arrays.
 * @param values An array with values. Use built-in arrays.
 * @param effort Optional level of effort.
 * @available flow control
 */" />
        <method name="deleteMIPStarts" argument2="int" argument1="int"  javaDoc="/**
 * Deletes the designated number of MIP starts, starting
 * from the MIP start specified by its index.
 *
 * @param first MIP start index to start deleting from.
 * @param nb Number of MIP starts to delete.
 * @available flow control
 */" />
        <method name="getMIPStart"  type="string" argument2="arrayof_dvar float" argument3="arrayof_float" argument1="int" argument4="arrayof_IloBool"  javaDoc="/**
 * Returns the level of effort associated with the MIP start
 * identified by &lt;code&gt;mipstartindex&lt;/code&gt; and defined by the arrays
 * &lt;code&gt;dvars&lt;/code&gt; and &lt;code&gt;vals&lt;/code&gt;. The argument &lt;code&gt;isset&lt;/code&gt;
 * designates which members of &lt;code&gt;dvars&lt;/code&gt; and which corresponding
 * values of &lt;code&gt;values&lt;/code&gt; participate in the MIP start - one of:
 * &lt;code&gt;&quot;MIPStartAuto&quot;, &quot;MIPStartCheckFeas&quot;, &quot;MIPStartSolveFixed&quot;, &quot;MIPStartSolveMIP&quot;, &quot;MIPStartRepair&quot;&lt;/code&gt;.
 * For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 * @type string
 * @param mipstartindex MIP start index.
 * @param dvars An array with decision variables. Use built-in arrays.
 * @param values An array with values. Use built-in arrays.
 * @param isset An array to designate which members of &lt;code&gt;dvars&lt;/code&gt; and which corresponding
 * values of &lt;code&gt;values&lt;/code&gt; participate in the MIP start
 * @return The effort level.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getMIPStartName"  type="string" argument1="int"  javaDoc="/**
 * Returns the name of the MIP start identified by its index.
 * For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 * @type string
 * @param mipstartindex MIP start index.
 * @return The name of the MIP start.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getMIPStartIndex"  type="int" argument1="string"  javaDoc="/**
 * Returns the index of the MIP start designated by its name.
 * For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 * @type int
 * @param name The name of the MIP start.
 * @return the MIP start index.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="conversion" argument3="string" argument1="dvar float" argument2="string"  javaDoc="/**
 * Creates an &lt;code&gt;IloConversion&lt;/code&gt; object,
 * with the specified name, for converting the 
 * type of a variable in a model.
 * The type is one of &lt;code&gt;&quot;ILOINT&quot;, &quot;ILOFLOAT&quot;, &quot;ILOBOOL&quot;&lt;/code&gt;.
 * For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 *
 * @param dvar The variable, the type of which is to be converted.
 * @param type The converted type for variable &lt;code&gt;dvar&lt;/code&gt;.
 * @param name Optional name of the new &lt;code&gt;IloConversion&lt;/code&gt; object.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="readMIPStarts"  type="void" argument1="string"  javaDoc="/**
 * Reads the MST file denoted by &lt;code&gt;name&lt;/code&gt; and
 * copies the MIP start information into the invoking &lt;code&gt;IloCplex&lt;/code&gt;
 * object.  The parameter &lt;code&gt;AdvInd&lt;/code&gt; must be turned on 
 * (its default is 1 (one))
 * in order for the MIP start information to be used with
 * a subsequent MIP optimization.    
 *
 * &lt;p&gt;By convention, the file extension is &lt;code&gt;.mst&lt;/code&gt;. 
 * The MST file format is documented in the reference manual
 * &lt;em&gt;CPLEX File Formats&lt;/em&gt; and in 
 * the stylesheet &lt;code&gt;solution.xsl&lt;/code&gt; and schema
 * &lt;code&gt;solution.xsd&lt;/code&gt; in the &lt;code&gt;include&lt;/code&gt; directory
 * of the product. Examples of its use appear in the examples
 * distributed with the product and in the 
 * &lt;em&gt;CPLEX User&apos;s Manual&lt;/em&gt;.
 * &lt;/p&gt;  
 * @type void
 * @param name The MSR file name.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="writeMIPStarts"  type="void" argument1="string" argument3="int" argument2="int"  javaDoc="/**
 * &lt;p&gt;Writes MIP start information to the file denoted by
 * &lt;code&gt;name&lt;/code&gt;.  The designated MIP starts  
 * begin with the one designated by the index
 * &lt;code&gt;first&lt;/code&gt; and continue to the specified number
 * &lt;code&gt;nb&lt;/code&gt; of members.
 * All MIP starts will be written if the
 * &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;nb&lt;/code&gt; arguments are
 * omitted.  The single MIP start designated by &lt;code&gt;first&lt;/code&gt;
 * will be written if the &lt;code&gt;num&lt;/code&gt; argument is
 * omitted.&lt;/p&gt;
 * &lt;p&gt;By convention, the file extension is &lt;code&gt;.mst&lt;/code&gt;.
 * &lt;/p&gt;
 * @type void
 * @param name The MST file name.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="readOrder"  type="void" argument1="string"  javaDoc="/**
 * Reads a priority order from a file in ORD format into
 * the invoking &lt;code&gt;IloCplex&lt;/code&gt; object.  The names in the ORD file
 * must match the names in the active model.  The priority order will
 * be associated with the model.  The parameter &lt;code&gt;MipOrdInd&lt;/code&gt;
 * must be nonzero for the next invocation of the method 
 * &lt;code&gt;IloCplex.solve&lt;/code&gt; to take
 * the order into account.
 *
 * &lt;p&gt; 
 * By convention, the file extension is &lt;code&gt;.ord&lt;/code&gt;.
 * The ORD file format is documented in the reference manual
 * &lt;em&gt;CPLEX File Formats&lt;/em&gt;.
 * &lt;/p&gt;
 * @type void  
 * @param name The file name.
 * @available postprocessing
 * @available flow control
 */" />
        <method name="getObjCoef"  type="number" argument1="dvar float"  javaDoc="/**
 * Returns the coefficient of a decision variable in the objective expression.
 *
 * @type number
 * @return the coefficient of the decision variable in the objective expression.
 * @param dvar The decision variable.
 * @available flow control
 */" />
        <method name="setArrayCoefs" argument1="constraint" argument2="arrayof_dvar float" argument3="arrayof_float"  javaDoc="/**
 * Sets the coefficients for an array of decision variables in a constraint.
 *
 * @param ct The linear constraint
 * @param dvars The array of decision variables new coefficient.
 * @param coefs The array of new coefficients (same size as variable array)
 * @available flow control
 */" />
        <method name="getCoef"  type="number" argument2="dvar float" argument1="constraint"  javaDoc="/**
 * returns the coefficient of the variable in the constraint; returns 0 if not mentioned.
 *
 * @type number
 * @return the coefficient of the decision variable in a constraint.
 * @param ct  The constraint in which we search the coefficient.
 * @param dvar The decision variable for which we need the coefficient.
 * @available flow control
 */" />
        <method name="setBounds" argument1="arrayof_range float" argument2="arrayof_float" argument3="arrayof_float"  javaDoc="/**
* Sets the lower and upper bounds of the ranged constraints.
*
* @param ranges An array of ranges.
* @param lbs An array of lower bounds.
* @param ubs An array of upper bounds.
* @available all
*/" />
        <method name="readVMConfig"  type="void" argument1="string"  javaDoc="/**
* Reads a CPLEX VM Config file.
*
* @type void
* @param file CPLEX VM Config file.
* @available all
*/" />
        <method name="copyVMConfig"  type="void" argument1="string"  javaDoc="/**
* Copy a CPLEX VM Config file.
*
* @type void
* @param xml CPLEX VM Config XML string.
* @available all
*/" />
        <method name="delVMConfig"  type="void"  javaDoc="/**
* Deletes a CPLEX VM Config file.
*
* @type void
* @available all
*/" />
        <method name="hasVMConfig"  type="void"  javaDoc="/**
* Returns if the CPLEX has a VM Config file.
*
* @type void
* @return Returns true or false
* @available all
*/" />
        <method name="_cplex_param_name_" isProperty="true"  type="string"  javaDoc="/**
 * Accesses a CPLEX parameter by its name.
 *
 * @type string
 * @available all
 */" />
        <method name="status" isProperty="true"  type="int"  javaDoc="/**
 * Status of the last method invoked on this object.
 * 
 * See the section &lt;b&gt;CPLEX solution status&lt;/b&gt; in &lt;i&gt;Language User&apos;s Manual &gt; 
 * ILOG Script for OPL &gt; Introduction to scripting &gt; Preprocessing and postprocessing 
 * &gt; Changing option values &gt; Changing CPLEX parameters&lt;/i&gt; for details of
 * the solution status codes.
 *
 * @type int
 * @available flow control
 */" />
       <method name="lex_TimeLimits" isProperty="true"  type="arrayof_int"  javaDoc="/**
 * Time limits for lexicographic objective.
 * 
 * @type int[]
 * @available flow control
 */" />
       <method name="lex_GapLimits" isProperty="true"  type="arrayof_float"  javaDoc="/**
 * Gap limits for lexicographic objective.
 * 
 * @type float[]
 * @available flow control
 */" />
        <method name="solnPoolNsolns" isProperty="true"  type="int"  javaDoc="/**
 * The number of solutions currently in the solution pool.
 * For more information, see the class &lt;code&gt;IloCplex&lt;/code&gt; in the &lt;i&gt;CPLEX C++ Reference Manual&lt;/i&gt;.
 * 
 * @type int
 * @available flow control
 */" />
        <method name="solve"  type="boolean"  javaDoc="/**
 * Solves the model currently extracted to the invoking &lt;code&gt;IloCplex&lt;/code&gt; object. 
 * The method returns &lt;code&gt;true&lt;/code&gt; if it finds a solution (not necessarily an optimal one).
 *
 * @type boolean
 * @return &lt;code&gt;true&lt;/code&gt; if the solve has been successful.
 * @available flow control
 */" />
        <method name="solveFixed"  type="boolean" argument1="sol"  javaDoc="/**
 * Solves the fixed active model using a solution from the solution pool.
 *
 * @type boolean
 * @return &lt;code&gt;true&lt;/code&gt; if the solve has been successful.
 * @param optional solution pool number.
 * @available flow control
 */" />
        <method name="delSolnPoolSolns"  type="void" argument2="int" argument1="int"  javaDoc="/**
* Deletes a range of solutions from the solution pool and renumbers 
* the indices of the remaining solutions in the pool.
*
* @param first A start index.
* @param end An end index 
* @type void
* @available all
*/" />
        <method name="freePresolve"  type="void"  javaDoc="/**
* This method frees the presolved problem. 
* Under the default setting of parameter &lt;code&gt;Reduce&lt;/code&gt;, the presolved problem 
* is freed when an optimal solution is found; however, 
* it is not freed if &lt;code&gt;Reduce&lt;/code&gt; has been set to 1 (primal reductions) or to 2 (dual reductions). 
* In these instances, the function &lt;code&gt;freePresolve&lt;/code&gt; can be used when necessary to free it manually.
* @type void
* @available all
*/" />
        <method name="getBoundSA"  javaDoc="/**
* See IloCplex reference documentation.
* @ignore
* @available nowhere
*/" />
        <method name="getObjSA"  javaDoc="/**
* See IloCplex reference documentation.
* @ignore
* @available nowhere
*/" />
        <method name="getInfeasibilities"  javaDoc="/**
* See IloCplex reference documentation.
* @ignore
* @available nowhere
*/" />
        <method name="getReducedCosts"  javaDoc="/**
* See IloCplex reference documentation.
* @ignore
* @available nowhere
*/" />
        <method name="getNfilters"  type="int"  javaDoc="/**
* Returns the number of filters currently associated with the solution pool.
* @type int
* @return The number of filters.
* @available postprocessing
* @available flow control
*/" />
        <method name="setArrayBounds" argument1="arrayof_constraint" argument2="arrayof_float" argument3="arrayof_float"  javaDoc="/**
* Sets the bounds of an array of constraints
* @param cts An array of constraints.
* @param lbs Lower bounds.
* @param ubs Upper bounds.
* @available all
*/" />
        <method name="setArrayLbs" argument1="arrayof_constraint" argument2="arrayof_float"  javaDoc="/**
* Sets the lower bounds of an array of constraints.
* @param cts An array of constraints.
* @param lbs Lower bounds.
* @available all
*/" />
        <method name="setArrayUbs" argument1="arrayof_constraint" argument2="arrayof_float"  javaDoc="/**
* Sets the upper bounds of an array of constraints.
* @param cts An array of constraints.
* @param ubs Upper bounds.
* @available all
*/" />
        <method name="setPriority" argument1="dvar float" argument2="float"  javaDoc="/**
* Sets the priority order of a decision variable.
*
* @param dvar Decision variable.
* @param priority New priority number.
* @available all
*/" />
        <method name="getPriority"  type="float" argument1="dvar float"  javaDoc="/**
* Accesses the priority level of a decision variable.
*
* @type float
* @param dvar Decision variable.
* @return The priority level of the given decision variable.
* @available all
*/" />
        <method name="getNiterations"  type="int"  javaDoc="/**
* Accesses the total number of iterations executed so far during the current optimization
* to solve the node relaxations.
*
* @type int
* @return The priority of the given decision variable.
* @available postprocessing
* @available flow control
*/" />
        <method name="getNnodes"  type="int"  javaDoc="/**
* Accesses the number of nodes already processed in the current optimization.
*
* @type int
* @return The priority of the given decision variable.
* @available postprocessing
* @available flow control
*/" />
<method name="getMultiObjNsolves"  type="int"  javaDoc="/**
* Accesses the number of sub-problems in a multi-objective solve.
*
* @type int
* @return The number of sub-problems in a multi-objective solve.
* @available postprocessing
* @available flow control
*/" />
        <method name="getMultiObjInfo"  argument1="string" argument2="int" type="float"  javaDoc="/**
* Returns info on given sub-problem of a multi-objective solve.
*
* @type float
* @return The info on the sub-problem of a multi-objective solve
* @param info The requested info
* @param num The sub-problem index
* @available postprocessing
* @available flow control
*/" />
        <method name="end"  type="int"  javaDoc="/**
 * Releases the memory used by this object.
 * The object then becomes unavailable for further usage.
 *
 * @available flow control
 */" />
      </methods>
    </class>
    <class name="IloOplScriptHCplexParams">
      <methods>
        <method name="advind" isProperty="true" cpx="CPX_PARAM_ADVIND" id="1001" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="aggfill" isProperty="true" cpx="CPX_PARAM_AGGFILL" id="1002" type="long" min="0" max="9223372036800000000">
        </method>
        <method name="aggind" isProperty="true" cpx="CPX_PARAM_AGGIND" id="1003" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="cfilemul" isProperty="true" cpx="CPX_PARAM_CFILEMUL" id="1005" type="IloBool">
        </method>
        <method name="clocktype" isProperty="true" cpx="CPX_PARAM_CLOCKTYPE" id="1006" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="craind" isProperty="true" cpx="CPX_PARAM_CRAIND" id="1007" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="depind" isProperty="true" cpx="CPX_PARAM_DEPIND" id="1008" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="dpriind" isProperty="true" cpx="CPX_PARAM_DPRIIND" id="1009" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="pricelim" isProperty="true" cpx="CPX_PARAM_PRICELIM" id="1010" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="epmrk" isProperty="true" cpx="CPX_PARAM_EPMRK" id="1013" type="IloBool">
        </method>
        <method name="epopt" isProperty="true" cpx="CPX_PARAM_EPOPT" id="1014" type="IloBool">
        </method>
        <method name="epper" isProperty="true" cpx="CPX_PARAM_EPPER" id="1015" type="IloBool">
        </method>
        <method name="eprhs" isProperty="true" cpx="CPX_PARAM_EPRHS" id="1016" type="IloBool">
        </method>
        <method name="simdisplay" isProperty="true" cpx="CPX_PARAM_SIMDISPLAY" id="1019" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="itlim" isProperty="true" cpx="CPX_PARAM_ITLIM" id="1020" type="long" min="0" max="9223372036800000000">
        </method>
        <method name="rowreadlim" isProperty="true" cpx="CPX_PARAM_ROWREADLIM" id="1021" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="netfind" isProperty="true" cpx="CPX_PARAM_NETFIND" id="1022" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="colreadlim" isProperty="true" cpx="CPX_PARAM_COLREADLIM" id="1023" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="nzreadlim" isProperty="true" cpx="CPX_PARAM_NZREADLIM" id="1024" type="long" min="0" max="9223372036800000000">
        </method>
        <method name="objllim" isProperty="true" cpx="CPX_PARAM_OBJLLIM" id="1025" type="IloBool">
        </method>
        <method name="objulim" isProperty="true" cpx="CPX_PARAM_OBJULIM" id="1026" type="IloBool">
        </method>
        <method name="perind" isProperty="true" cpx="CPX_PARAM_PERIND" id="1027" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="perlim" isProperty="true" cpx="CPX_PARAM_PERLIM" id="1028" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="ppriind" isProperty="true" cpx="CPX_PARAM_PPRIIND" id="1029" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="preind" isProperty="true" cpx="CPX_PARAM_PREIND" id="1030" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="reinv" isProperty="true" cpx="CPX_PARAM_REINV" id="1031" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="rfilemul" isProperty="true" cpx="CPX_PARAM_RFILEMUL" id="1033" type="IloBool">
        </method>
        <method name="scaind" isProperty="true" cpx="CPX_PARAM_SCAIND" id="1034" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="scrind" isProperty="true" cpx="CPX_PARAM_SCRIND" id="1035" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="singlim" isProperty="true" cpx="CPX_PARAM_SINGLIM" id="1037" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="singtol" isProperty="true" cpx="CPX_PARAM_SINGTOL" id="1038" type="IloBool">
        </method>
        <method name="tilim" isProperty="true" cpx="CPX_PARAM_TILIM" id="1039" type="IloBool">
        </method>
        <method name="predual" isProperty="true" cpx="CPX_PARAM_PREDUAL" id="1044" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="prepass" isProperty="true" cpx="CPX_PARAM_PREPASS" id="1052" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="datacheck" isProperty="true" cpx="CPX_PARAM_DATACHECK" id="1056" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="reduce" isProperty="true" cpx="CPX_PARAM_REDUCE" id="1057" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="prelinear" isProperty="true" cpx="CPX_PARAM_PRELINEAR" id="1058" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="rootalg" isProperty="true" cpx="CPX_PARAM_LPMETHOD" id="1062" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="rootalg" isProperty="true" cpx="CPX_PARAM_QPMETHOD" id="1063" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="workdir" isProperty="true" cpx="CPX_PARAM_WORKDIR" id="1064" type="string">
        </method>
        <method name="workmem" isProperty="true" cpx="CPX_PARAM_WORKMEM" id="1065" type="IloBool">
        </method>
        <method name="threads" isProperty="true" cpx="CPX_PARAM_THREADS" id="1067" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="conflictalg" isProperty="true" cpx="CPX_PARAM_CONFLICTALG" id="1073" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="conflictdisplay" isProperty="true" cpx="CPX_PARAM_CONFLICTDISPLAY" id="1074" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="siftdisplay" isProperty="true" cpx="CPX_PARAM_SIFTDISPLAY" id="1076" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="siftalg" isProperty="true" cpx="CPX_PARAM_SIFTALG" id="1077" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="siftitlim" isProperty="true" cpx="CPX_PARAM_SIFTITLIM" id="1078" type="long" min="0" max="9223372036800000000">
        </method>
        <method name="mpslongnum" isProperty="true" cpx="CPX_PARAM_MPSLONGNUM" id="1081" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="memoryemphasis" isProperty="true" cpx="CPX_PARAM_MEMORYEMPHASIS" id="1082" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="numericalemphasis" isProperty="true" cpx="CPX_PARAM_NUMERICALEMPHASIS" id="1083" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="feasoptmode" isProperty="true" cpx="CPX_PARAM_FEASOPTMODE" id="1084" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="parallelmode" isProperty="true" cpx="CPX_PARAM_PARALLELMODE" id="1109" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="tuningmeasure" isProperty="true" cpx="CPX_PARAM_TUNINGMEASURE" id="1110" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="tuningrepeat" isProperty="true" cpx="CPX_PARAM_TUNINGREPEAT" id="1111" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="tuningtilim" isProperty="true" cpx="CPX_PARAM_TUNINGTILIM" id="1112" type="IloBool">
        </method>
        <method name="tuningdisplay" isProperty="true" cpx="CPX_PARAM_TUNINGDISPLAY" id="1113" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="writelevel" isProperty="true" cpx="CPX_PARAM_WRITELEVEL" id="1114" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="randomseed" isProperty="true" cpx="CPX_PARAM_RANDOMSEED" id="1124" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="dettilim" isProperty="true" cpx="CPX_PARAM_DETTILIM" id="1127" type="IloBool">
        </method>
        <method name="fileencoding" isProperty="true" cpx="CPX_PARAM_FILEENCODING" id="1129" type="string">
        </method>
        <method name="apiencoding" isProperty="true" cpx="CPX_PARAM_APIENCODING" id="1130" type="string">
        </method>
        <method name="optimalitytarget" isProperty="true" cpx="CPX_PARAM_OPTIMALITYTARGET" id="1131" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="clonelog" isProperty="true" cpx="CPX_PARAM_CLONELOG" id="1132" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="tuningdettilim" isProperty="true" cpx="CPX_PARAM_TUNINGDETTILIM" id="1139" type="IloBool">
        </method>
        <method name="cpumask" isProperty="true" cpx="CPX_PARAM_CPUMASK" id="1144" type="string">
        </method>
        <method name="solutiontype" isProperty="true" cpx="CPX_PARAM_SOLUTIONTYPE" id="1147" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="siftsim" isProperty="true" cpx="CPX_PARAM_SIFTSIM" id="1158" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="workeralg" isProperty="true" cpx="CPX_PARAM_WORKERALG" id="1500" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="bendersstrategy" isProperty="true" cpx="CPX_PARAM_BENDERSSTRATEGY" id="1501" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="bendersfeascuttol" isProperty="true" cpx="CPX_PARAM_BENDERSFEASCUTTOL" id="1509" type="IloBool">
        </method>
        <method name="bendersoptcuttol" isProperty="true" cpx="CPX_PARAM_BENDERSOPTCUTTOL" id="1510" type="IloBool">
        </method>
        <method name="brdir" isProperty="true" cpx="CPX_PARAM_BRDIR" id="2001" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="bttol" isProperty="true" cpx="CPX_PARAM_BTTOL" id="2002" type="IloBool">
        </method>
        <method name="cliques" isProperty="true" cpx="CPX_PARAM_CLIQUES" id="2003" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="coeredind" isProperty="true" cpx="CPX_PARAM_COEREDIND" id="2004" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="covers" isProperty="true" cpx="CPX_PARAM_COVERS" id="2005" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="cutlo" isProperty="true" cpx="CPX_PARAM_CUTLO" id="2006" type="IloBool">
        </method>
        <method name="cutup" isProperty="true" cpx="CPX_PARAM_CUTUP" id="2007" type="IloBool">
        </method>
        <method name="epagap" isProperty="true" cpx="CPX_PARAM_EPAGAP" id="2008" type="IloBool">
        </method>
        <method name="epgap" isProperty="true" cpx="CPX_PARAM_EPGAP" id="2009" type="IloBool">
        </method>
        <method name="epint" isProperty="true" cpx="CPX_PARAM_EPINT" id="2010" type="IloBool">
        </method>
        <method name="mipdisplay" isProperty="true" cpx="CPX_PARAM_MIPDISPLAY" id="2012" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="mipinterval" isProperty="true" cpx="CPX_PARAM_MIPINTERVAL" id="2013" type="long" min="-9223372036800000000" max="9223372036800000000">
        </method>
        <method name="intsollim" isProperty="true" cpx="CPX_PARAM_INTSOLLIM" id="2015" type="long" min="1" max="9223372036800000000">
        </method>
        <method name="nodefileind" isProperty="true" cpx="CPX_PARAM_NODEFILEIND" id="2016" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="nodelim" isProperty="true" cpx="CPX_PARAM_NODELIM" id="2017" type="long" min="0" max="9223372036800000000">
        </method>
        <method name="nodesel" isProperty="true" cpx="CPX_PARAM_NODESEL" id="2018" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="objdif" isProperty="true" cpx="CPX_PARAM_OBJDIF" id="2019" type="IloBool">
        </method>
        <method name="mipordind" isProperty="true" cpx="CPX_PARAM_MIPORDIND" id="2020" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="relobjdif" isProperty="true" cpx="CPX_PARAM_RELOBJDIF" id="2022" type="IloBool">
        </method>
        <method name="rootalg" isProperty="true" cpx="CPX_PARAM_STARTALG" id="2025" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="nodealg" isProperty="true" cpx="CPX_PARAM_SUBALG" id="2026" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="trelim" isProperty="true" cpx="CPX_PARAM_TRELIM" id="2027" type="IloBool">
        </method>
        <method name="varsel" isProperty="true" cpx="CPX_PARAM_VARSEL" id="2028" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="bndstrenind" isProperty="true" cpx="CPX_PARAM_BNDSTRENIND" id="2029" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="heurfreq" isProperty="true" cpx="CPX_PARAM_HEURFREQ" id="2031" type="long" min="-1" max="9223372036800000000">
        </method>
        <method name="mipordtype" isProperty="true" cpx="CPX_PARAM_MIPORDTYPE" id="2032" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="cutsfactor" isProperty="true" cpx="CPX_PARAM_CUTSFACTOR" id="2033" type="IloBool">
        </method>
        <method name="relaxpreind" isProperty="true" cpx="CPX_PARAM_RELAXPREIND" id="2034" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="preslvnd" isProperty="true" cpx="CPX_PARAM_PRESLVND" id="2037" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="bbinterval" isProperty="true" cpx="CPX_PARAM_BBINTERVAL" id="2039" type="long" min="0" max="9223372036800000000">
        </method>
        <method name="flowcovers" isProperty="true" cpx="CPX_PARAM_FLOWCOVERS" id="2040" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="implbd" isProperty="true" cpx="CPX_PARAM_IMPLBD" id="2041" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="probe" isProperty="true" cpx="CPX_PARAM_PROBE" id="2042" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="gubcovers" isProperty="true" cpx="CPX_PARAM_GUBCOVERS" id="2044" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="strongcandlim" isProperty="true" cpx="CPX_PARAM_STRONGCANDLIM" id="2045" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="strongitlim" isProperty="true" cpx="CPX_PARAM_STRONGITLIM" id="2046" type="long" min="0" max="9223372036800000000">
        </method>
        <method name="fraccand" isProperty="true" cpx="CPX_PARAM_FRACCAND" id="2048" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="fraccuts" isProperty="true" cpx="CPX_PARAM_FRACCUTS" id="2049" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="fracpass" isProperty="true" cpx="CPX_PARAM_FRACPASS" id="2050" type="long" min="0" max="9223372036800000000">
        </method>
        <method name="flowpaths" isProperty="true" cpx="CPX_PARAM_FLOWPATHS" id="2051" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="mircuts" isProperty="true" cpx="CPX_PARAM_MIRCUTS" id="2052" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="disjcuts" isProperty="true" cpx="CPX_PARAM_DISJCUTS" id="2053" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="aggcutlim" isProperty="true" cpx="CPX_PARAM_AGGCUTLIM" id="2054" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="mipcbredlp" isProperty="true" cpx="CPX_PARAM_MIPCBREDLP" id="2055">
        </method>
        <method name="cutpass" isProperty="true" cpx="CPX_PARAM_CUTPASS" id="2056" type="long" min="-1" max="9223372036800000000">
        </method>
        <method name="mipemphasis" isProperty="true" cpx="CPX_PARAM_MIPEMPHASIS" id="2058" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="symmetry" isProperty="true" cpx="CPX_PARAM_SYMMETRY" id="2059" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="divetype" isProperty="true" cpx="CPX_PARAM_DIVETYPE" id="2060" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="rinsheur" isProperty="true" cpx="CPX_PARAM_RINSHEUR" id="2061" type="long" min="-2" max="9223372036800000000">
        </method>
        <method name="submipnodelimit" isProperty="true" cpx="CPX_PARAM_SUBMIPNODELIMIT" id="2212" type="long" min="1" max="9223372036800000000">
        </method>
        <method name="lbheur" isProperty="true" cpx="CPX_PARAM_LBHEUR" id="2063" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="repeatpresolve" isProperty="true" cpx="CPX_PARAM_REPEATPRESOLVE" id="2064" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="probetime" isProperty="true" cpx="CPX_PARAM_PROBETIME" id="2065" type="IloBool">
        </method>
        <method name="polishtime" isProperty="true" cpx="CPX_PARAM_POLISHTIME" id="2066" type="IloBool">
        </method>
        <method name="repairtries" isProperty="true" cpx="CPX_PARAM_REPAIRTRIES" id="2067" type="long" min="-1" max="9223372036800000000">
        </method>
        <method name="eprelax" isProperty="true" cpx="CPX_PARAM_EPRELAX" id="2073" type="IloBool">
        </method>
        <method name="fpheur" isProperty="true" cpx="CPX_PARAM_FPHEUR" id="2098" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="eachcutlim" isProperty="true" cpx="CPX_PARAM_EACHCUTLIM" id="2102" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="solnpoolcapacity" isProperty="true" cpx="CPX_PARAM_SOLNPOOLCAPACITY" id="2103" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="solnpoolreplace" isProperty="true" cpx="CPX_PARAM_SOLNPOOLREPLACE" id="2104" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="solnpoolgap" isProperty="true" cpx="CPX_PARAM_SOLNPOOLGAP" id="2105" type="IloBool">
        </method>
        <method name="solnpoolagap" isProperty="true" cpx="CPX_PARAM_SOLNPOOLAGAP" id="2106" type="IloBool">
        </method>
        <method name="solnpoolintensity" isProperty="true" cpx="CPX_PARAM_SOLNPOOLINTENSITY" id="2107" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="populatelim" isProperty="true" cpx="CPX_PARAM_POPULATELIM" id="2108" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="mipsearch" isProperty="true" cpx="CPX_PARAM_MIPSEARCH" id="2109" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="miqcpstrat" isProperty="true" cpx="CPX_PARAM_MIQCPSTRAT" id="2110" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="zerohalfcuts" isProperty="true" cpx="CPX_PARAM_ZEROHALFCUTS" id="2111" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="polishafterepagap" isProperty="true" cpx="CPX_PARAM_POLISHAFTEREPAGAP" id="2126" type="IloBool">
        </method>
        <method name="polishafterepgap" isProperty="true" cpx="CPX_PARAM_POLISHAFTEREPGAP" id="2127" type="IloBool">
        </method>
        <method name="polishafternode" isProperty="true" cpx="CPX_PARAM_POLISHAFTERNODE" id="2128" type="long" min="0" max="9223372036800000000">
        </method>
        <method name="polishafterintsol" isProperty="true" cpx="CPX_PARAM_POLISHAFTERINTSOL" id="2129" type="long" min="1" max="9223372036800000000">
        </method>
        <method name="polishaftertime" isProperty="true" cpx="CPX_PARAM_POLISHAFTERTIME" id="2130" type="IloBool">
        </method>
        <method name="mcfcuts" isProperty="true" cpx="CPX_PARAM_MCFCUTS" id="2134" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="mipkappastats" isProperty="true" cpx="CPX_PARAM_MIPKAPPASTATS" id="2137" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="auxrootthreads" isProperty="true" cpx="CPX_PARAM_AUXROOTTHREADS" id="2139" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="intsolfileprefix" isProperty="true" cpx="CPX_PARAM_INTSOLFILEPREFIX" id="2143" type="string">
        </method>
        <method name="probedettime" isProperty="true" cpx="CPX_PARAM_PROBEDETTIME" id="2150" type="IloBool">
        </method>
        <method name="polishafterdettime" isProperty="true" cpx="CPX_PARAM_POLISHAFTERDETTIME" id="2151" type="IloBool">
        </method>
        <method name="landpcuts" isProperty="true" cpx="CPX_PARAM_LANDPCUTS" id="2152" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="rampupduration" isProperty="true" cpx="CPX_PARAM_RAMPUPDURATION" id="2163" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="rampupdettilim" isProperty="true" cpx="CPX_PARAM_RAMPUPDETTILIM" id="2164" type="IloBool">
        </method>
        <method name="rampuptilim" isProperty="true" cpx="CPX_PARAM_RAMPUPTILIM" id="2165" type="IloBool">
        </method>
        <method name="localimplbd" isProperty="true" cpx="CPX_PARAM_LOCALIMPLBD" id="2181" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="bqpcuts" isProperty="true" cpx="CPX_PARAM_BQPCUTS" id="2195" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="rltcuts" isProperty="true" cpx="CPX_PARAM_RLTCUTS" id="2196" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="submipstartalg" isProperty="true" cpx="CPX_PARAM_SUBMIPSTARTALG" id="2205" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="submipsubalg" isProperty="true" cpx="CPX_PARAM_SUBMIPSUBALG" id="2206" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="submipscaind" isProperty="true" cpx="CPX_PARAM_SUBMIPSCAIND" id="2207" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="barepcomp" isProperty="true" cpx="CPX_PARAM_BAREPCOMP" id="3002" type="IloBool">
        </method>
        <method name="bargrowth" isProperty="true" cpx="CPX_PARAM_BARGROWTH" id="3003" type="IloBool">
        </method>
        <method name="barobjrng" isProperty="true" cpx="CPX_PARAM_BAROBJRNG" id="3004" type="IloBool">
        </method>
        <method name="baralg" isProperty="true" cpx="CPX_PARAM_BARALG" id="3007" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="barcolnz" isProperty="true" cpx="CPX_PARAM_BARCOLNZ" id="3009" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="bardisplay" isProperty="true" cpx="CPX_PARAM_BARDISPLAY" id="3010" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="baritlim" isProperty="true" cpx="CPX_PARAM_BARITLIM" id="3012" type="long" min="0" max="9223372036800000000">
        </method>
        <method name="barmaxcor" isProperty="true" cpx="CPX_PARAM_BARMAXCOR" id="3013" type="long" min="-1" max="9223372036800000000">
        </method>
        <method name="barorder" isProperty="true" cpx="CPX_PARAM_BARORDER" id="3014" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="barstartalg" isProperty="true" cpx="CPX_PARAM_BARSTARTALG" id="3017" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="barcrossalg" isProperty="true" cpx="CPX_PARAM_BARCROSSALG" id="3018" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="barqcpepcomp" isProperty="true" cpx="CPX_PARAM_BARQCPEPCOMP" id="3020" type="IloBool">
        </method>
        <method name="qpnzreadlim" isProperty="true" cpx="CPX_PARAM_QPNZREADLIM" id="4001" type="long" min="0" max="9223372036800000000">
        </method>
        <method name="calcqcpduals" isProperty="true" cpx="CPX_PARAM_CALCQCPDUALS" id="4003" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="qpmakepsdind" isProperty="true" cpx="CPX_PARAM_QPMAKEPSDIND" id="4010" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="qtolinind" isProperty="true" cpx="CPX_PARAM_QTOLININD" id="4012" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="netitlim" isProperty="true" cpx="CPX_PARAM_NETITLIM" id="5001" type="long" min="0" max="9223372036800000000">
        </method>
        <method name="netepopt" isProperty="true" cpx="CPX_PARAM_NETEPOPT" id="5002" type="IloBool">
        </method>
        <method name="neteprhs" isProperty="true" cpx="CPX_PARAM_NETEPRHS" id="5003" type="IloBool">
        </method>
        <method name="netppriind" isProperty="true" cpx="CPX_PARAM_NETPPRIIND" id="5004" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
        <method name="netdisplay" isProperty="true" cpx="CPX_PARAM_NETDISPLAY" id="5005" type="float" min="1.65087e-316" max="7.44846e-318">
        </method>
      </methods>
    </class>
    <class name="IloOplScriptHCpParams">
      <methods>
        <method name="AutomaticReplay" isProperty="true" id="29" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;AutomaticReplay&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="BranchLimit" isProperty="true" id="28" type="int" isAuto="0" min="0" max="9.0072e+15" default="9.0072e+15" javaDoc="&lt;p&gt;BranchLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=9.0072e+15&lt;/p&gt;">
        </method>
        <method name="CPOFileStrictIdCount" isProperty="true" id="124" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;CPOFileStrictIdCount&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="ChoicePointLimit" isProperty="true" id="10" type="int" isAuto="0" min="0" max="9.0072e+15" default="9.0072e+15" javaDoc="&lt;p&gt;ChoicePointLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=9.0072e+15&lt;/p&gt;">
        </method>
        <method name="ConflictDefinition" isProperty="true" id="102" type="int" isAuto="0" min="40" max="42" default="40" javaDoc="&lt;p&gt;ConflictDefinition&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=40 &lt;b>max&lt;/b&gt;=42&lt;b&gt; default&lt;/b&gt;=40&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;ConflictInfeasible = 40&lt;/li&gt;&lt;li&gt;ConflictHard = 41&lt;/li&gt;&lt;li&gt;ConflictComplementaryFeasible = 42&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="ConflictInfeasible" value="40" />
          <symbol name="ConflictHard" value="41" />
          <symbol name="ConflictComplementaryFeasible" value="42" />
        </symbols>
        </method>
        <method name="ConflictRefinerAlgorithm" isProperty="true" id="66" type="int" isAuto="0" min="0" max="3" default="3" javaDoc="&lt;p&gt;ConflictRefinerAlgorithm&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=3&lt;b&gt; default&lt;/b&gt;=3&lt;/p&gt;">
        </method>
        <method name="ConflictRefinerBranchLimit" isProperty="true" id="62" type="int" isAuto="0" min="0" max="9.0072e+15" default="9.0072e+15" javaDoc="&lt;p&gt;ConflictRefinerBranchLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=9.0072e+15&lt;/p&gt;">
        </method>
        <method name="ConflictRefinerFailLimit" isProperty="true" id="63" type="int" isAuto="0" min="0" max="9.0072e+15" default="9.0072e+15" javaDoc="&lt;p&gt;ConflictRefinerFailLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=9.0072e+15&lt;/p&gt;">
        </method>
        <method name="ConflictRefinerIterationLimit" isProperty="true" id="61" type="int" isAuto="0" min="0" max="9.0072e+15" default="9.0072e+15" javaDoc="&lt;p&gt;ConflictRefinerIterationLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=9.0072e+15&lt;/p&gt;">
        </method>
        <method name="ConflictRefinerOnLabeledConstraints" isProperty="true" id="65" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;ConflictRefinerOnLabeledConstraints&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="ConflictRefinerOnVariables" isProperty="true" id="64" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;ConflictRefinerOnVariables&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="ConflictRefinerTimeLimit" isProperty="true" id="1012" type="float" isAuto="0" min="0" max="inf" default="inf" javaDoc="&lt;p&gt;ConflictRefinerTimeLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=inf&lt;b&gt; default&lt;/b&gt;=inf&lt;/p&gt;">
        </method>
        <method name="ConflictRefinerWriteMode" isProperty="true" id="101" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;ConflictRefinerWriteMode&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;">
        </method>
        <method name="EliminatePresolvedModel" isProperty="true" id="69" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;EliminatePresolvedModel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="FailLimit" isProperty="true" id="9" type="int" isAuto="0" min="0" max="9.0072e+15" default="9.0072e+15" javaDoc="&lt;p&gt;FailLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=9.0072e+15&lt;/p&gt;">
        </method>
        <method name="ForbidIncludeDirective" isProperty="true" id="110" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;ForbidIncludeDirective&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="LogDisplayWorkerIdleTime" isProperty="true" id="75" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;LogDisplayWorkerIdleTime&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MemoryDisplay" isProperty="true" id="81" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;MemoryDisplay&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="ObjectiveLimit" isProperty="true" id="37" type="float" isAuto="0" min="-inf" max="inf" default="inf" javaDoc="&lt;p&gt;ObjectiveLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=-inf &lt;b>max&lt;/b&gt;=inf&lt;b&gt; default&lt;/b&gt;=inf&lt;/p&gt;">
        </method>
        <method name="ParallelCommunicateEachSolution" isProperty="true" id="73" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;ParallelCommunicateEachSolution&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="ParallelEventQueueCapacity" isProperty="true" id="74" type="int" isAuto="1" min="1" max="9.0072e+15" default="-1" javaDoc="&lt;p&gt;ParallelEventQueueCapacity&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=1 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;">
        </method>
        <method name="ParallelMode" isProperty="true" id="70" type="int" isAuto="1" min="0" max="1" default="-1" javaDoc="&lt;p&gt;ParallelMode&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;">
        </method>
        <method name="ParallelOptimizeSingleWorker" isProperty="true" id="88" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;ParallelOptimizeSingleWorker&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="ParallelRestartProp" isProperty="true" id="1010" type="float" isAuto="0" min="-1" max="1" default="-1" javaDoc="&lt;p&gt;ParallelRestartProp&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=-1 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;">
        </method>
        <method name="ParallelSkipEquivalentSolutions" isProperty="true" id="89" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;ParallelSkipEquivalentSolutions&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="ParallelSynchronizationTicks" isProperty="true" id="71" type="int" isAuto="1" min="0" max="9.0072e+15" default="-1" javaDoc="&lt;p&gt;ParallelSynchronizationTicks&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;">
        </method>
        <method name="ParallelWorkerStackSize" isProperty="true" id="59" type="int" isAuto="1" min="0" max="9.0072e+15" default="-1" javaDoc="&lt;p&gt;ParallelWorkerStackSize&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;">
        </method>
        <method name="PrintModelDetailsInMessages" isProperty="true" id="109" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;PrintModelDetailsInMessages&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="SameMessageLimit" isProperty="true" id="121" type="int" isAuto="0" min="1" max="9.0072e+15" default="20" javaDoc="&lt;p&gt;SameMessageLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=1 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=20&lt;/p&gt;">
        </method>
        <method name="SolutionLimit" isProperty="true" id="35" type="int" isAuto="0" min="0" max="9.0072e+15" default="9.0072e+15" javaDoc="&lt;p&gt;SolutionLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=9.0072e+15&lt;/p&gt;">
        </method>
        <method name="StrongMaxTuples" isProperty="true" id="76" type="int" isAuto="0" min="0" max="9.0072e+15" default="10000" javaDoc="&lt;p&gt;StrongMaxTuples&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=10000&lt;/p&gt;">
        </method>
        <method name="TraceExtraction" isProperty="true" id="31" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;TraceExtraction&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="WarningLevel" isProperty="true" id="90" type="int" isAuto="0" min="0" max="3" default="2" javaDoc="&lt;p&gt;WarningLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=3&lt;b&gt; default&lt;/b&gt;=2&lt;/p&gt;">
        </method>
        <method name="Workers" isProperty="true" id="25" type="int" isAuto="1" min="1" max="9.0072e+15" default="-1" javaDoc="&lt;p&gt;Workers&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=1 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;">
        </method>
        <method name="AllDiffInferenceLevel" isProperty="true" id="2" type="int" isAuto="0" min="2" max="6" default="2" javaDoc="&lt;p&gt;AllDiffInferenceLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=2 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=2&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Default = 2&lt;/li&gt;&lt;li&gt;Low = 3&lt;/li&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Default" value="2" />
          <symbol name="Low" value="3" />
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="AllMinDistanceInferenceLevel" isProperty="true" id="6" type="int" isAuto="0" min="2" max="6" default="2" javaDoc="&lt;p&gt;AllMinDistanceInferenceLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=2 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=2&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Default = 2&lt;/li&gt;&lt;li&gt;Low = 3&lt;/li&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Default" value="2" />
          <symbol name="Low" value="3" />
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="CPOFileCompatibility" isProperty="true" id="93" type="int" isAuto="1" min="0" max="9.0072e+15" default="-1" javaDoc="&lt;p&gt;CPOFileCompatibility&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;">
        </method>
        <method name="CountDifferentInferenceLevel" isProperty="true" id="104" type="int" isAuto="0" min="2" max="6" default="2" javaDoc="&lt;p&gt;CountDifferentInferenceLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=2 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=2&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Default = 2&lt;/li&gt;&lt;li&gt;Low = 3&lt;/li&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Default" value="2" />
          <symbol name="Low" value="3" />
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="CountInferenceLevel" isProperty="true" id="4" type="int" isAuto="0" min="2" max="6" default="2" javaDoc="&lt;p&gt;CountInferenceLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=2 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=2&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Default = 2&lt;/li&gt;&lt;li&gt;Low = 3&lt;/li&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Default" value="2" />
          <symbol name="Low" value="3" />
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="CumulFunctionInferenceLevel" isProperty="true" id="41" type="int" isAuto="0" min="2" max="6" default="2" javaDoc="&lt;p&gt;CumulFunctionInferenceLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=2 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=2&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Default = 2&lt;/li&gt;&lt;li&gt;Low = 3&lt;/li&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Default" value="2" />
          <symbol name="Low" value="3" />
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="DefaultInferenceLevel" isProperty="true" id="1" type="int" isAuto="0" min="3" max="6" default="4" javaDoc="&lt;p&gt;DefaultInferenceLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=3 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=4&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Low = 3&lt;/li&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Low" value="3" />
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="DistributeInferenceLevel" isProperty="true" id="3" type="int" isAuto="0" min="2" max="6" default="2" javaDoc="&lt;p&gt;DistributeInferenceLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=2 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=2&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Default = 2&lt;/li&gt;&lt;li&gt;Low = 3&lt;/li&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Default" value="2" />
          <symbol name="Low" value="3" />
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="DynamicProbing" isProperty="true" id="32" type="int" isAuto="1" min="0" max="1" default="-1" javaDoc="&lt;p&gt;DynamicProbing&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Auto = -1&lt;/li&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Auto" value="-1" />
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="DynamicProbingStrength" isProperty="true" id="1005" type="float" isAuto="0" min="0.001" max="1000" default="0.03" javaDoc="&lt;p&gt;DynamicProbingStrength&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0.001 &lt;b>max&lt;/b&gt;=1000&lt;b&gt; default&lt;/b&gt;=0.03&lt;/p&gt;">
        </method>
        <method name="ElementInferenceLevel" isProperty="true" id="7" type="int" isAuto="0" min="2" max="6" default="2" javaDoc="&lt;p&gt;ElementInferenceLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=2 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=2&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Default = 2&lt;/li&gt;&lt;li&gt;Low = 3&lt;/li&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Default" value="2" />
          <symbol name="Low" value="3" />
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="EnforceCELimits" isProperty="true" id="129" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;EnforceCELimits&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="FDSConfiguration" isProperty="true" id="111" type="int" isAuto="0" min="0" max="9.0072e+15" default="0" javaDoc="&lt;p&gt;FDSConfiguration&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;">
        </method>
        <method name="FDSDecayFactor" isProperty="true" id="1019" type="float" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;FDSDecayFactor&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;">
        </method>
        <method name="FDSExtraFilteringDepth" isProperty="true" id="113" type="int" isAuto="1" min="0" max="9.0072e+15" default="-1" javaDoc="&lt;p&gt;FDSExtraFilteringDepth&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;">
        </method>
        <method name="FDSFailBonus" isProperty="true" id="1021" type="float" isAuto="0" min="0" max="inf" default="1" javaDoc="&lt;p&gt;FDSFailBonus&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=inf&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;">
        </method>
        <method name="FDSMinChoicesPerInterval" isProperty="true" id="114" type="int" isAuto="0" min="0" max="9.0072e+15" default="0" javaDoc="&lt;p&gt;FDSMinChoicesPerInterval&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;">
        </method>
        <method name="FDSMinRandomDepth" isProperty="true" id="115" type="int" isAuto="0" min="0" max="9.0072e+15" default="20" javaDoc="&lt;p&gt;FDSMinRandomDepth&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=20&lt;/p&gt;">
        </method>
        <method name="FDSPortionForRandomDraw" isProperty="true" id="1022" type="float" isAuto="0" min="0" max="inf" default="1" javaDoc="&lt;p&gt;FDSPortionForRandomDraw&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=inf&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;">
        </method>
        <method name="FDSRandomPeriod" isProperty="true" id="112" type="int" isAuto="0" min="0" max="9.0072e+15" default="100" javaDoc="&lt;p&gt;FDSRandomPeriod&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=100&lt;/p&gt;">
        </method>
        <method name="FDSRootStrongBranches" isProperty="true" id="116" type="int" isAuto="0" min="0" max="9.0072e+15" default="20" javaDoc="&lt;p&gt;FDSRootStrongBranches&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=20&lt;/p&gt;">
        </method>
        <method name="FDSStrongBranchingDepth" isProperty="true" id="123" type="int" isAuto="0" min="-1" max="9.0072e+15" default="8" javaDoc="&lt;p&gt;FDSStrongBranchingDepth&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=-1 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=8&lt;/p&gt;">
        </method>
        <method name="FDSStrongBranchingStartDepth" isProperty="true" id="122" type="int" isAuto="0" min="0" max="9.0072e+15" default="0" javaDoc="&lt;p&gt;FDSStrongBranchingStartDepth&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;">
        </method>
        <method name="FailureDirectedSearch" isProperty="true" id="78" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;FailureDirectedSearch&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="FailureDirectedSearchEmphasis" isProperty="true" id="1018" type="float" isAuto="1" min="0" max="9.0072e+15" default="-1" javaDoc="&lt;p&gt;FailureDirectedSearchEmphasis&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;">
        </method>
        <method name="FailureDirectedSearchMaxMemory" isProperty="true" id="79" type="int" isAuto="0" min="0" max="9.0072e+15" default="1.04858e+08" javaDoc="&lt;p&gt;FailureDirectedSearchMaxMemory&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=1.04858e+08&lt;/p&gt;">
        </method>
        <method name="FloatDisplay" isProperty="true" id="24" type="int" isAuto="0" min="7" max="11" default="9" javaDoc="&lt;p&gt;FloatDisplay&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=7 &lt;b>max&lt;/b&gt;=11&lt;b&gt; default&lt;/b&gt;=9&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Standard = 7&lt;/li&gt;&lt;li&gt;IntScientific = 8&lt;/li&gt;&lt;li&gt;IntFixed = 9&lt;/li&gt;&lt;li&gt;BasScientific = 10&lt;/li&gt;&lt;li&gt;BasFixed = 11&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Standard" value="7" />
          <symbol name="IntScientific" value="8" />
          <symbol name="IntFixed" value="9" />
          <symbol name="BasScientific" value="10" />
          <symbol name="BasFixed" value="11" />
        </symbols>
        </method>
        <method name="ImpactMeasures" isProperty="true" id="18" type="int" isAuto="1" min="0" max="1" default="-1" javaDoc="&lt;p&gt;ImpactMeasures&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Auto = -1&lt;/li&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Auto" value="-1" />
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="IntervalSequenceInferenceLevel" isProperty="true" id="39" type="int" isAuto="0" min="2" max="6" default="2" javaDoc="&lt;p&gt;IntervalSequenceInferenceLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=2 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=2&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Default = 2&lt;/li&gt;&lt;li&gt;Low = 3&lt;/li&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Default" value="2" />
          <symbol name="Low" value="3" />
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="IntervalSolutionPoolCapacity" isProperty="true" id="53" type="int" isAuto="0" min="1" max="9.0072e+15" default="1" javaDoc="&lt;p&gt;IntervalSolutionPoolCapacity&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=1 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;">
        </method>
        <method name="LogPeriod" isProperty="true" id="12" type="int" isAuto="0" min="1" max="9.0072e+15" default="1000" javaDoc="&lt;p&gt;LogPeriod&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=1 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=1000&lt;/p&gt;">
        </method>
        <method name="LogSearchTags" isProperty="true" id="107" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;LogSearchTags&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="LogVerbosity" isProperty="true" id="11" type="int" isAuto="0" min="20" max="23" default="22" javaDoc="&lt;p&gt;LogVerbosity&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=20 &lt;b>max&lt;/b&gt;=23&lt;b&gt; default&lt;/b&gt;=22&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Quiet = 20&lt;/li&gt;&lt;li&gt;Terse = 21&lt;/li&gt;&lt;li&gt;Normal = 22&lt;/li&gt;&lt;li&gt;Verbose = 23&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Quiet" value="20" />
          <symbol name="Terse" value="21" />
          <symbol name="Normal" value="22" />
          <symbol name="Verbose" value="23" />
        </symbols>
        </method>
        <method name="LowerBoundEffort" isProperty="true" id="1006" type="float" isAuto="0" min="-1" max="1.79769e+308" default="1" javaDoc="&lt;p&gt;LowerBoundEffort&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=-1 &lt;b>max&lt;/b&gt;=1.79769e+308&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;">
        </method>
        <method name="MaxNoGoodLength" isProperty="true" id="126" type="int" isAuto="0" min="0" max="2.14748e+09" default="30" javaDoc="&lt;p&gt;MaxNoGoodLength&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=2.14748e+09&lt;b&gt; default&lt;/b&gt;=30&lt;/p&gt;">
        </method>
        <method name="MaxNoGoods" isProperty="true" id="33" type="int" isAuto="0" min="0" max="9.0072e+15" default="9.0072e+15" javaDoc="&lt;p&gt;MaxNoGoods&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=9.0072e+15&lt;/p&gt;">
        </method>
        <method name="MaxPBTCaptureSize" isProperty="true" id="103" type="int" isAuto="0" min="0" max="9.0072e+15" default="1e+06" javaDoc="&lt;p&gt;MaxPBTCaptureSize&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=1e+06&lt;/p&gt;">
        </method>
        <method name="MinPBTCaptureSize" isProperty="true" id="108" type="int" isAuto="0" min="0" max="9.0072e+15" default="100" javaDoc="&lt;p&gt;MinPBTCaptureSize&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=100&lt;/p&gt;">
        </method>
        <method name="ModelAnonymizer" isProperty="true" id="77" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;ModelAnonymizer&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointConsiderSecondaryVariables" isProperty="true" id="99" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;MultiPointConsiderSecondaryVariables&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointDisableLamarckism" isProperty="true" id="58" type="int" isAuto="1" min="0" max="1" default="-1" javaDoc="&lt;p&gt;MultiPointDisableLamarckism&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Auto = -1&lt;/li&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Auto" value="-1" />
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointEncodeIntervalAlternatives" isProperty="true" id="84" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;MultiPointEncodeIntervalAlternatives&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointEncodeIntervalExecutions" isProperty="true" id="85" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;MultiPointEncodeIntervalExecutions&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointEncodeIntervalPrecedences" isProperty="true" id="82" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;MultiPointEncodeIntervalPrecedences&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointEncodeIntervalSequences" isProperty="true" id="83" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;MultiPointEncodeIntervalSequences&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointEncodeIntervalTimes" isProperty="true" id="86" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;MultiPointEncodeIntervalTimes&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointEncodeObjectives" isProperty="true" id="87" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;MultiPointEncodeObjectives&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointEncodingPercentage" isProperty="true" id="17" type="float" isAuto="0" min="0" max="100" default="20" javaDoc="&lt;p&gt;MultiPointEncodingPercentage&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=100&lt;b&gt; default&lt;/b&gt;=20&lt;/p&gt;">
        </method>
        <method name="MultiPointIgnorePhases" isProperty="true" id="98" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;MultiPointIgnorePhases&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointImproveDuringInit" isProperty="true" id="105" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;MultiPointImproveDuringInit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointLearningRatio" isProperty="true" id="1011" type="float" isAuto="1" min="0" max="1" default="-1" javaDoc="&lt;p&gt;MultiPointLearningRatio&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;">
        </method>
        <method name="MultiPointMaximumFailLimit" isProperty="true" id="57" type="int" isAuto="0" min="0" max="9.0072e+15" default="1024" javaDoc="&lt;p&gt;MultiPointMaximumFailLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=1024&lt;/p&gt;">
        </method>
        <method name="MultiPointNumberOfSearchPoints" isProperty="true" id="16" type="int" isAuto="0" min="2" max="9.0072e+15" default="30" javaDoc="&lt;p&gt;MultiPointNumberOfSearchPoints&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=2 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=30&lt;/p&gt;">
        </method>
        <method name="MultiPointPropagationLimitFactor" isProperty="true" id="1008" type="float" isAuto="1" min="0" max="inf" default="-1" javaDoc="&lt;p&gt;MultiPointPropagationLimitFactor&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=inf&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;">
        </method>
        <method name="MultiPointRandomOperatorEncodingFactor" isProperty="true" id="1015" type="float" isAuto="1" min="0" max="inf" default="0" javaDoc="&lt;p&gt;MultiPointRandomOperatorEncodingFactor&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=inf&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;">
        </method>
        <method name="MultiPointReduceIntervalPrecedences" isProperty="true" id="97" type="int" isAuto="1" min="0" max="1" default="0" javaDoc="&lt;p&gt;MultiPointReduceIntervalPrecedences&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Auto = -1&lt;/li&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Auto" value="-1" />
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointRestartProbability" isProperty="true" id="1016" type="float" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;MultiPointRestartProbability&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;">
        </method>
        <method name="MultiPointRestartRatio" isProperty="true" id="1017" type="float" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;MultiPointRestartRatio&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;">
        </method>
        <method name="MultiPointUseApproximateAssignment" isProperty="true" id="92" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;MultiPointUseApproximateAssignment&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointUseCrossoverOperator" isProperty="true" id="95" type="int" isAuto="1" min="0" max="1" default="-1" javaDoc="&lt;p&gt;MultiPointUseCrossoverOperator&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Auto = -1&lt;/li&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Auto" value="-1" />
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointUseMutationOperator" isProperty="true" id="96" type="int" isAuto="1" min="0" max="1" default="-1" javaDoc="&lt;p&gt;MultiPointUseMutationOperator&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Auto = -1&lt;/li&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Auto" value="-1" />
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointUseRandomOperator" isProperty="true" id="94" type="int" isAuto="1" min="0" max="1" default="-1" javaDoc="&lt;p&gt;MultiPointUseRandomOperator&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Auto = -1&lt;/li&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Auto" value="-1" />
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="MultiPointWeightAlleleFactories" isProperty="true" id="91" type="int" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;MultiPointWeightAlleleFactories&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="NoOverlapInferenceLevel" isProperty="true" id="40" type="int" isAuto="0" min="2" max="6" default="2" javaDoc="&lt;p&gt;NoOverlapInferenceLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=2 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=2&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Default = 2&lt;/li&gt;&lt;li&gt;Low = 3&lt;/li&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Default" value="2" />
          <symbol name="Low" value="3" />
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="OptimalityTolerance" isProperty="true" id="1001" type="float" isAuto="0" min="0" max="inf" default="1e-09" javaDoc="&lt;p&gt;OptimalityTolerance&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=inf&lt;b&gt; default&lt;/b&gt;=1e-09&lt;/p&gt;">
        </method>
        <method name="PackApproximationSize" isProperty="true" id="22" type="int" isAuto="0" min="32" max="9.0072e+15" default="512" javaDoc="&lt;p&gt;PackApproximationSize&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=32 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=512&lt;/p&gt;">
        </method>
        <method name="ParallelCommunicateSolutions" isProperty="true" id="72" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;ParallelCommunicateSolutions&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="ParallelCommunicatesLowerBounds" isProperty="true" id="120" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;ParallelCommunicatesLowerBounds&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="ParallelCommunicatesNoGoods" isProperty="true" id="119" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;ParallelCommunicatesNoGoods&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="PrecedenceInferenceLevel" isProperty="true" id="38" type="int" isAuto="0" min="2" max="6" default="2" javaDoc="&lt;p&gt;PrecedenceInferenceLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=2 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=2&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Default = 2&lt;/li&gt;&lt;li&gt;Low = 3&lt;/li&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Default" value="2" />
          <symbol name="Low" value="3" />
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="Presolve" isProperty="true" id="60" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;Presolve&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="PresolveConfiguration" isProperty="true" id="127" type="int" isAuto="0" min="0" max="9.0072e+15" default="0" javaDoc="&lt;p&gt;PresolveConfiguration&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;">
        </method>
        <method name="PresolveIterations" isProperty="true" id="106" type="int" isAuto="0" min="1" max="9.0072e+15" default="1" javaDoc="&lt;p&gt;PresolveIterations&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=1 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;">
        </method>
        <method name="PresolveLevel" isProperty="true" id="36" type="int" isAuto="0" min="4" max="6" default="5" javaDoc="&lt;p&gt;PresolveLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=4 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=5&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="PresolveTransformers" isProperty="true" id="68" type="int" isAuto="0" min="0" max="2.14748e+09" default="2.14748e+09" javaDoc="&lt;p&gt;PresolveTransformers&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=2.14748e+09&lt;b&gt; default&lt;/b&gt;=2.14748e+09&lt;/p&gt;">
        </method>
        <method name="PresolveTransformers2" isProperty="true" id="125" type="int" isAuto="0" min="0" max="2.14748e+09" default="2.14748e+09" javaDoc="&lt;p&gt;PresolveTransformers2&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=2.14748e+09&lt;b&gt; default&lt;/b&gt;=2.14748e+09&lt;/p&gt;">
        </method>
        <method name="PropagationLog" isProperty="true" id="27" type="int" isAuto="0" min="20" max="23" default="20" javaDoc="&lt;p&gt;PropagationLog&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=20 &lt;b>max&lt;/b&gt;=23&lt;b&gt; default&lt;/b&gt;=20&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Quiet = 20&lt;/li&gt;&lt;li&gt;Terse = 21&lt;/li&gt;&lt;li&gt;Normal = 22&lt;/li&gt;&lt;li&gt;Verbose = 23&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Quiet" value="20" />
          <symbol name="Terse" value="21" />
          <symbol name="Normal" value="22" />
          <symbol name="Verbose" value="23" />
        </symbols>
        </method>
        <method name="RandomSeed" isProperty="true" id="14" type="int" isAuto="0" min="0" max="9.0072e+15" default="0" javaDoc="&lt;p&gt;RandomSeed&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;">
        </method>
        <method name="RelativeOptimalityTolerance" isProperty="true" id="1002" type="float" isAuto="0" min="0" max="inf" default="0.0001" javaDoc="&lt;p&gt;RelativeOptimalityTolerance&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=inf&lt;b&gt; default&lt;/b&gt;=0.0001&lt;/p&gt;">
        </method>
        <method name="RestartFailLimit" isProperty="true" id="15" type="int" isAuto="0" min="1" max="9.0072e+15" default="100" javaDoc="&lt;p&gt;RestartFailLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=1 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=100&lt;/p&gt;">
        </method>
        <method name="RestartGrowthFactor" isProperty="true" id="1004" type="float" isAuto="0" min="1" max="1.79769e+308" default="1.15" javaDoc="&lt;p&gt;RestartGrowthFactor&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=1 &lt;b>max&lt;/b&gt;=1.79769e+308&lt;b&gt; default&lt;/b&gt;=1.15&lt;/p&gt;">
        </method>
        <method name="RestartProofEmphasis" isProperty="true" id="1007" type="float" isAuto="0" min="0" max="1" default="0.3" javaDoc="&lt;p&gt;RestartProofEmphasis&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0.3&lt;/p&gt;">
        </method>
        <method name="RestartPropagationLimitFactor" isProperty="true" id="1009" type="float" isAuto="1" min="0" max="inf" default="30" javaDoc="&lt;p&gt;RestartPropagationLimitFactor&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=inf&lt;b&gt; default&lt;/b&gt;=30&lt;/p&gt;">
        </method>
        <method name="RestartTimeMeasurement" isProperty="true" id="56" type="int" isAuto="0" min="0" max="4" default="1" javaDoc="&lt;p&gt;RestartTimeMeasurement&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=4&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;">
        </method>
        <method name="RestartWithTDRSearch" isProperty="true" id="128" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;RestartWithTDRSearch&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="SACLimit" isProperty="true" id="130" type="int" isAuto="0" min="0" max="9.0072e+15" default="0" javaDoc="&lt;p&gt;SACLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;">
        </method>
        <method name="SACSkip" isProperty="true" id="131" type="int" isAuto="0" min="3" max="9.0072e+15" default="6" javaDoc="&lt;p&gt;SACSkip&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=3 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=6&lt;/p&gt;">
        </method>
        <method name="SearchConfiguration" isProperty="true" id="48" type="int" isAuto="0" min="0" max="9.0072e+15" default="0" javaDoc="&lt;p&gt;SearchConfiguration&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;">
        </method>
        <method name="SearchType" isProperty="true" id="13" type="int" isAuto="1" min="24" max="27" default="-1" javaDoc="&lt;p&gt;SearchType&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=24 &lt;b>max&lt;/b&gt;=26&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Auto = -1&lt;/li&gt;&lt;li&gt;DepthFirst = 24&lt;/li&gt;&lt;li&gt;Restart = 25&lt;/li&gt;&lt;li&gt;MultiPoint = 26&lt;li&gt;IterativeDiving = 27&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Auto" value="-1" />
          <symbol name="DepthFirst" value="24" />
          <symbol name="Restart" value="25" />
          <symbol name="MultiPoint" value="26" />
         <symbol name="IterativeDiving" value="27" />
        </symbols>
        </method>
        <method name="SeedRandomOnSolve" isProperty="true" id="30" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;SeedRandomOnSolve&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="SequenceExpressionInferenceLevel" isProperty="true" id="50" type="int" isAuto="0" min="2" max="6" default="2" javaDoc="&lt;p&gt;SequenceExpressionInferenceLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=2 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=2&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Default = 2&lt;/li&gt;&lt;li&gt;Low = 3&lt;/li&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Default" value="2" />
          <symbol name="Low" value="3" />
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="SequenceInferenceLevel" isProperty="true" id="5" type="int" isAuto="0" min="2" max="6" default="2" javaDoc="&lt;p&gt;SequenceInferenceLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=2 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=2&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Default = 2&lt;/li&gt;&lt;li&gt;Low = 3&lt;/li&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Default" value="2" />
          <symbol name="Low" value="3" />
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="StateFunctionInferenceLevel" isProperty="true" id="42" type="int" isAuto="0" min="2" max="6" default="2" javaDoc="&lt;p&gt;StateFunctionInferenceLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=2 &lt;b>max&lt;/b&gt;=6&lt;b&gt; default&lt;/b&gt;=2&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Default = 2&lt;/li&gt;&lt;li&gt;Low = 3&lt;/li&gt;&lt;li&gt;Basic = 4&lt;/li&gt;&lt;li&gt;Medium = 5&lt;/li&gt;&lt;li&gt;Extended = 6&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Default" value="2" />
          <symbol name="Low" value="3" />
          <symbol name="Basic" value="4" />
          <symbol name="Medium" value="5" />
          <symbol name="Extended" value="6" />
        </symbols>
        </method>
        <method name="StateFunctionTriangularInequalityCheck" isProperty="true" id="51" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;StateFunctionTriangularInequalityCheck&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="StrictNumericalDivision" isProperty="true" id="23" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;StrictNumericalDivision&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="StrongMinReduction" isProperty="true" id="1014" type="float" isAuto="0" min="0" max="1" default="0" javaDoc="&lt;p&gt;StrongMinReduction&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=0&lt;/p&gt;">
        </method>
        <method name="SynchronizeByDeterministicTime" isProperty="true" id="80" type="int" isAuto="1" min="0" max="1" default="-1" javaDoc="&lt;p&gt;SynchronizeByDeterministicTime&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Auto = -1&lt;/li&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Auto" value="-1" />
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="TTEF" isProperty="true" id="54" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;TTEF&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="TemporalRelaxation" isProperty="true" id="44" type="int" isAuto="1" min="0" max="1" default="-1" javaDoc="&lt;p&gt;TemporalRelaxation&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=-1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Auto = -1&lt;/li&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Auto" value="-1" />
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
        <method name="TemporalRelaxationAlgorithm" isProperty="true" id="55" type="int" isAuto="0" min="0" max="22" default="18" javaDoc="&lt;p&gt;TemporalRelaxationAlgorithm&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=22&lt;b&gt; default&lt;/b&gt;=18&lt;/p&gt;">
        </method>
        <method name="TemporalRelaxationIterationLimit" isProperty="true" id="47" type="int" isAuto="0" min="0" max="9.0072e+15" default="50000" javaDoc="&lt;p&gt;TemporalRelaxationIterationLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=50000&lt;/p&gt;">
        </method>
        <method name="TemporalRelaxationLevel" isProperty="true" id="45" type="int" isAuto="0" min="0" max="10" default="3" javaDoc="&lt;p&gt;TemporalRelaxationLevel&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=10&lt;b&gt; default&lt;/b&gt;=3&lt;/p&gt;">
        </method>
        <method name="TemporalRelaxationRowLimit" isProperty="true" id="46" type="int" isAuto="0" min="0" max="9.0072e+15" default="150000" javaDoc="&lt;p&gt;TemporalRelaxationRowLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=9.0072e+15&lt;b&gt; default&lt;/b&gt;=150000&lt;/p&gt;">
        </method>
        <method name="TemporalRelaxationTimeFactor" isProperty="true" id="1013" type="float" isAuto="0" min="0" max="inf" default="1000" javaDoc="&lt;p&gt;TemporalRelaxationTimeFactor&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=inf&lt;b&gt; default&lt;/b&gt;=1000&lt;/p&gt;">
        </method>
        <method name="TimeDisplay" isProperty="true" id="34" type="int" isAuto="0" min="30" max="32" default="30" javaDoc="&lt;p&gt;TimeDisplay&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=30 &lt;b>max&lt;/b&gt;=32&lt;b&gt; default&lt;/b&gt;=30&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Seconds = 30&lt;/li&gt;&lt;li&gt;HoursMinutesSeconds = 31&lt;/li&gt;&lt;li&gt;NoTime = 32&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Seconds" value="30" />
          <symbol name="HoursMinutesSeconds" value="31" />
          <symbol name="NoTime" value="32" />
        </symbols>
        </method>
        <method name="TimeLimit" isProperty="true" id="1003" type="float" isAuto="0" min="0" max="inf" default="inf" javaDoc="&lt;p&gt;TimeLimit&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=inf&lt;b&gt; default&lt;/b&gt;=inf&lt;/p&gt;">
        </method>
        <method name="TimeMode" isProperty="true" id="43" type="int" isAuto="0" min="33" max="34" default="34" javaDoc="&lt;p&gt;TimeMode&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=33 &lt;b>max&lt;/b&gt;=34&lt;b&gt; default&lt;/b&gt;=34&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;CPUTime = 33&lt;/li&gt;&lt;li&gt;ElapsedTime = 34&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="CPUTime" value="33" />
          <symbol name="ElapsedTime" value="34" />
        </symbols>
        </method>
        <method name="TimetablingAlgorithm" isProperty="true" id="67" type="int" isAuto="0" min="0" max="2" default="1" javaDoc="&lt;p&gt;TimetablingAlgorithm&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=2&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;">
        </method>
        <method name="UseFileLocations" isProperty="true" id="100" type="int" isAuto="0" min="0" max="1" default="1" javaDoc="&lt;p&gt;UseFileLocations&lt;/p&gt;&lt;p&gt;&lt;b&gt;min&lt;/b&gt;=0 &lt;b>max&lt;/b&gt;=1&lt;b&gt; default&lt;/b&gt;=1&lt;/p&gt;&lt;p&gt;Possible values&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Off = 0&lt;/li&gt;&lt;li&gt;On = 1&lt;/li&gt;&lt;/ul&gt;">
        <symbols>
          <symbol name="Off" value="0" />
          <symbol name="On" value="1" />
        </symbols>
        </method>
      </methods>
    </class>
    <class name="IloOplScriptHCpInfos">
      <methods>
        <method name="AverageFailDepth" isProperty="true" id="2021" type="float">
        </method>
        <method name="DecisionDescription" isProperty="true" id="2005" type="float">
        </method>
        <method name="DepthFirstAverageIdleTime" isProperty="true" id="2026" type="float">
        </method>
        <method name="DepthFirstIdleTime" isProperty="true" id="1005" type="float">
        </method>
        <method name="DeterministicTimePerBranch" isProperty="true" id="2016" type="float">
        </method>
        <method name="EffectiveDepthFirstWorkers" isProperty="true" id="17" type="int">
        </method>
        <method name="EffectiveMultiPointWorkers" isProperty="true" id="18" type="int">
        </method>
        <method name="EffectiveOptimalityTolerance" isProperty="true" id="1004" type="float">
        </method>
        <method name="EffectiveRestartWorkers" isProperty="true" id="19" type="int">
        </method>
        <method name="EffectiveWorkers" isProperty="true" id="16" type="int">
        </method>
        <method name="EngineAverageIdleTime" isProperty="true" id="2027" type="float">
        </method>
        <method name="EngineIdleTime" isProperty="true" id="2028" type="float">
        </method>
        <method name="EngineIdleTimeCount" isProperty="true" id="2023" type="int">
        </method>
        <method name="EngineIdleTimeSum" isProperty="true" id="2022" type="int">
        </method>
        <method name="EngineMaxIdleTime" isProperty="true" id="2014" type="float">
        </method>
        <method name="EngineMemoryUsage" isProperty="true" id="2012" type="int">
        </method>
        <method name="EngineSearchType" isProperty="true" id="2001" type="int">
        </method>
        <method name="ExtractionTime" isProperty="true" id="1002" type="float">
        </method>
        <method name="FailDepthCount" isProperty="true" id="2009" type="int">
        </method>
        <method name="FailDepthSum" isProperty="true" id="2010" type="int">
        </method>
        <method name="FailStatus" isProperty="true" id="11" type="int">
        </method>
        <method name="Gap" isProperty="true" id="2000" type="float">
        </method>
        <method name="LowerBound" isProperty="true" id="2006" type="float">
        </method>
        <method name="MemoryUsage" isProperty="true" id="8" type="int">
        </method>
        <method name="MultiPointAverageIdleTime" isProperty="true" id="2024" type="float">
        </method>
        <method name="MultiPointIdleTime" isProperty="true" id="1007" type="float">
        </method>
        <method name="NumberOfAuxiliaryVariables" isProperty="true" id="5" type="int">
        </method>
        <method name="NumberOfBranches" isProperty="true" id="3" type="int">
        </method>
        <method name="NumberOfChoicePoints" isProperty="true" id="1" type="int">
        </method>
        <method name="NumberOfConstraints" isProperty="true" id="7" type="int">
        </method>
        <method name="NumberOfConstraintsAdded" isProperty="true" id="21" type="int">
        </method>
        <method name="NumberOfConstraintsAggregated" isProperty="true" id="9" type="int">
        </method>
        <method name="NumberOfConstraintsGenerated" isProperty="true" id="10" type="int">
        </method>
        <method name="NumberOfConstraintsRemoved" isProperty="true" id="22" type="int">
        </method>
        <method name="NumberOfCriteria" isProperty="true" id="23" type="int">
        </method>
        <method name="NumberOfEngineConstraints" isProperty="true" id="2018" type="int">
        </method>
        <method name="NumberOfEngineVariables" isProperty="true" id="6" type="int">
        </method>
        <method name="NumberOfErrors" isProperty="true" id="25" type="int">
        </method>
        <method name="NumberOfFails" isProperty="true" id="2" type="int">
        </method>
        <method name="NumberOfIntegerVariables" isProperty="true" id="12" type="int">
        </method>
        <method name="NumberOfIntervalVariables" isProperty="true" id="13" type="int">
        </method>
        <method name="NumberOfModelVariables" isProperty="true" id="2029" type="int">
        </method>
        <method name="NumberOfPresolveTransformations" isProperty="true" id="20" type="int">
        </method>
        <method name="NumberOfSequenceVariables" isProperty="true" id="14" type="int">
        </method>
        <method name="NumberOfSolutions" isProperty="true" id="15" type="int">
        </method>
        <method name="NumberOfStateFunctions" isProperty="true" id="28" type="int">
        </method>
        <method name="NumberOfUnboundModelVariables" isProperty="true" id="2002" type="int">
        </method>
        <method name="NumberOfUnboundModelVariablesInLogPeriod" isProperty="true" id="2020" type="int">
        </method>
        <method name="NumberOfVariables" isProperty="true" id="4" type="int">
        </method>
        <method name="NumberOfWarnings" isProperty="true" id="24" type="int">
        </method>
        <method name="NumberOfWorkerSynchronizations" isProperty="true" id="1008" type="int">
        </method>
        <method name="PeakMemoryUsage" isProperty="true" id="2017" type="int">
        </method>
        <method name="PresolveTime" isProperty="true" id="1009" type="float">
        </method>
        <method name="RestartAverageIdleTime" isProperty="true" id="2025" type="float">
        </method>
        <method name="RestartIdleTime" isProperty="true" id="1006" type="float">
        </method>
        <method name="SearchDeterministicTime" isProperty="true" id="2011" type="int">
        </method>
        <method name="SearchInfoType" isProperty="true" id="2007" type="int">
        </method>
        <method name="SearchMemoryUsage" isProperty="true" id="2013" type="int">
        </method>
        <method name="SearchStatus" isProperty="true" id="29" type="int">
        </method>
        <method name="Solution" isProperty="true" id="2003" type="float">
        </method>
        <method name="SolveTime" isProperty="true" id="1001" type="float">
        </method>
        <method name="TotalTime" isProperty="true" id="1003" type="float">
        </method>
        <method name="TreatmentStamp" isProperty="true" id="2015" type="int">
        </method>
        <method name="UpperBound" isProperty="true" id="2008" type="float">
        </method>
        <method name="WorkerId" isProperty="true" id="26" type="int">
        </method>
      </methods>
    </class>
  </classes>
  <functions>
        <function name="Infinity"  isGlobal="true" isVar="false" >
      <contexts>
                <context name="EVAL">        </context>
                <context name="POST">        </context>
                <context name="CPLEX">        </context>
                <context name="CP">        </context>
      </contexts>
    </function>
        <function name="IloOplSuper"  isGlobal="true" isVar="false"  javaDoc="/**
 * @ignore
 *
 * Implementation detail.
 */" >
      <contexts>
                <context name="EVAL">        </context>
                <context name="POST">        </context>
                <context name="CPLEX">        </context>
                <context name="CP">        </context>
      </contexts>
    </function>
        <function name="IloOplGetEnv"  isGlobal="true" isVar="false"  type="string" argument1="string"  javaDoc="/**
 * This function gives access to system environment variables.
 * &lt;p&gt;It calls the Standard C library function &lt;code&gt;getenv()&lt;/code&gt; internally.&lt;/p&gt;
 *
 * &lt;table class=&quot;NoteTable&quot; summary=&quot;Note table&quot;&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;span class=&quot;NoteTitle&quot;&gt;Note&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td class=&quot;Note&quot;&gt;&lt;a name=&quot;261983&quot; /&gt;
 * Do not confuse this function with the IBM ILOG Concert class &lt;code&gt;IloEnv&lt;/code&gt;,
 * which creates environment instances that manage memory and identifiers for modeling objects.
 * &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
 *
 * @example
 * execute {
 *   writeln(&quot; doesnotexist = &quot;,IloOplGetEnv(&quot;doesnotexist&quot;));
 *   writeln(&quot; PATH = &quot;,IloOplGetEnv(&quot;PATH&quot;));
 * }
 *
 * @globalFunction
 * @ilog.undocumented.jsFile
 * @type string
 * @param name The name of the environment variable.
 * @return The value of the environment variable, or &lt;code&gt;undefined&lt;/code&gt;.
 */" >
      <contexts>
                <context name="EVAL">        </context>
                <context name="POST">        </context>
                <context name="CPLEX">        </context>
                <context name="CP">        </context>
      </contexts>
    </function>
        <function name="IloOplExec"  isGlobal="true" isVar="false"  type="string" argument1="command"  javaDoc="/**
 *Exec command
 * @globalFunction
 * @ilog.undocumented.jsFile
 * @type string
 * @param command The command to be executed.
 * @return status.
 */" >
      <contexts>
                <context name="EVAL">        </context>
                <context name="POST">        </context>
                <context name="CPLEX">        </context>
                <context name="CP">        </context>
      </contexts>
    </function>
        <function name="includeScript"  isGlobal="true" isVar="false" argument1="string"  javaDoc="/**
* This function loads the script file passed as parameter. 
* &lt;p&gt;The path can be either absolute or relative.&lt;/p&gt; 
* &lt;p&gt;If this path does not designate an existing file, 
* the file is searched for using a method that depends on the application 
* in which the script is embedded. Typically, the name of the script file
* is searched for in a list of directories specified in the application setup.&lt;/p&gt;
* &lt;p&gt;The effect of this function is the same as for &lt;code&gt;loadFile&lt;/code&gt;. In OPL, you
* have to use &lt;code&gt;includeScript&lt;/code&gt;, as the function &lt;code&gt;loadFile&lt;/code&gt; 
* does not recognize OPL objects, such as &lt;code&gt;thisOplModel&lt;/code&gt;.&lt;/p&gt;
* &lt;p&gt; &lt;/p&gt;
* &lt;p&gt;&lt;b&gt;Limitation&lt;/b&gt;&lt;/p&gt;
* &lt;p&gt;Flow control instructions and global functions cannot be called from an external JavaScript file.&lt;/p&gt;
* &lt;p&gt;This limitation affects the following JavaScript classes:&lt;/p&gt;
* &lt;p&gt;&lt;code&gt;IloOplCplexBasis,  IloOplCplexVectors, IloOplDataElements, IloOplDataSource, 
* IloOplModelDefinition, IloOplModelSource&lt;/code&gt;&lt;/p&gt;
* &lt;p&gt;and JavaScript global functions:&lt;/p&gt;
* &lt;p&gt;&lt;code&gt;IloOplCallJava, IloOplGetEnv, IloOplImportJava&lt;/code&gt;&lt;/p&gt;
*
* &lt;p&gt;Example showing the limitation:&lt;/p&gt;
* &lt;p&gt;Consider a function, such as &lt;code&gt;myFunction&lt;/code&gt; below, in an external JavaScript file called &lt;code&gt;a.js&lt;/code&gt;.&lt;/p&gt;
* &lt;pre class=&quot;ShortCode&quot;&gt;
 * functionmyFunction(modName, masterOpl) { 
* 	 var subSource = new IloOplModelSource(modName); 
*  	 var subDef = new IloOplModelDefinition(subSource); 
* 	 var subCplex = new IloCplex(); 
*  	 [...] 
* } 
* &lt;/pre&gt;
*
* This example contains the limitation, as the file &lt;code&gt;a.js&lt;/code&gt; is called from a main execution block.
* &lt;pre class=&quot;ShortCode&quot;&gt;
*  main { 
*  [...] 
*  includeScript( &quot;a.js&quot; ); 
*  
* var res = myFunction(&quot;cutstock-sub.mod&quot;, masterOpl); 
*
*   [...] 
*
*} 
* &lt;/pre&gt;
*
* A workaround for this limitation is:
* &lt;pre class=&quot;ShortCode&quot;&gt;
* a.js: 
* functionmyFunction(Classes, modName, masterOpl) { 
* var subSource = new Classes[0](modName); 
* var subDef = new Classes[1](subSource); 
* var subCplex = new Classes[2](); 
* 
* var subOpl = new Classes[3](subDef,subCplex); 
* var subData = new Classes[4](); 
* [...] 
* } 
* &lt;/pre&gt;
* and in the main model:
* &lt;pre class=&quot;ShortCode&quot;&gt;
* main { 
*	[...] 
*	// Missing classes.... 
*	var classes = new Array( IloOplModelSource, IloOplModelDefinition, IloCplex, IloOplModel, IloOplDataElements); 
*	includeScript( &quot;a.js&quot; );    
*	[...]     
*	var res = myFunction(classes,&quot;cutstock-sub.mod&quot;, masterOpl); 
*	[...]     
*} 
* &lt;/pre&gt;
*
* @example
* execute {
*   includeScript(&quot;../kpiFile.js&quot;);
* }
*
* @globalFunction
* @ilog.undocumented.jsFile
* @param path The path of the file to be loaded.
*/" >
      <contexts>
                <context name="EVAL">        </context>
                <context name="POST">        </context>
                <context name="CPLEX">        </context>
                <context name="CP">        </context>
      </contexts>
    </function>
        <function name="IloOplImportJava"  isGlobal="true" isVar="false"  type="void" argument1="string"  javaDoc="/**
 * This function makes some Java classes available in scripting blocks.
 *
 * &lt;p&gt;It expands the search path for the next calls to &lt;code&gt;IloOplCallJava&lt;/code&gt;. &lt;/p&gt;
 * &lt;p&gt;This method uses the resolver path (see &lt;code&gt;IloOplSettings&lt;/code&gt;) to resolve the given path.
 *  Relative paths or JAR file names are searched relative to the model file directory as well as in
 *  other directories of the search path.&lt;/p&gt;
 * &lt;p&gt;It is not necessary that the added path exists and its existence is not checked, as with
 *    any Java classpath. 
 *    This allows you to add, for example, both the debug/release version of some classes in the path,
 *    and still work, whatever the version actually installed. &lt;/p&gt;
 * &lt;p&gt;If your classes are not properly defined in the path you give, a 
 *    script error is raised (&lt;code&gt;ClassNotFoundException&lt;/code&gt; exception) during the call to &lt;code&gt;IloOplCallJava&lt;/code&gt;. &lt;/p&gt;
 * 
 *  &lt;p&gt;The first call to this function initializes the Java call support in ILOG Script. 
 *  To do so, the implementation needs a Java Virtual Machine. If you are already running a Java Virtual Machine (as is the case in an OPL Java application
 *      or in an ODM application), that JVM is used. Otherwise, a new Java Virtual Machine is created. It looks
 *      for a Java Runtime Environment by using, in this order:&lt;/p&gt;
 *  &lt;ul&gt;
 *   &lt;li&gt;The Java Runtime Environment specified during ODM installation, if ODM has been installed&lt;/li&gt;
 *   &lt;li&gt;The Java Runtime Environment specified using the JAVA_HOME environment variable.&lt;/li&gt;       
 *   &lt;li&gt;The Java Runtime Environment found in the Windows registry (Windows-specific).&lt;/li&gt;       
 *   &lt;li&gt;The Java Runtime Environment found in the execution path.&lt;/li&gt;       
 *   &lt;li&gt;The Java Runtime Environment installed as part of the ODM installation, if ODM has been installed&lt;/li&gt;       
 *  &lt;/ul&gt;
 *  &lt;p&gt; &lt;b&gt;Note: &lt;/b&gt;If the environment variable JAVA_HOME is not set, the &lt;code&gt;IloOplImportJava&lt;/code&gt; function will not work.&lt;/p&gt;
 *  &lt;p&gt;When a new Java Virtual Machine is created, its classpath is initially set with the OPL JAR files 
 *  from the OPL installation. It also includes the ODM JAR files from the ODM installation if ODM
 *  has been installed. This allows the custom Java code to use the OPL and ODM Java APIs.&lt;/p&gt;
 *  &lt;p&gt;The OPL installation is found by using:&lt;/p&gt;
 *  &lt;ul&gt;
 *   &lt;li&gt;The position of the current executable (IDE or oplrun)&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;The ODM installation is found by using:&lt;/p&gt;
 *  &lt;ul&gt;
 *   &lt;li&gt;The Windows registry&lt;/li&gt;
 * &lt;/ul&gt;
 *  &lt;p&gt;Calling external functions is not possible if the application is statically linked with the 
 *	 OPL libraries (like oplrunsample). This is because the Java OPL library uses the
 *	  shared library version of OPL (&lt;code&gt;oplxx.dll/.so&lt;/code&gt;) which cannot be mixed with the static
 *	  version. You can use an external call to Java in the OPL IDE, in oplrun, and in custom OPL or
 *	  ODM applications launched from Java.&lt;/p&gt;
 *
 * @example
 * execute {
 *   IloOplImportJava(&quot;./classes&quot;); 
 *   IloOplImportJava(&quot;C:/myjars/my_global_classes.jar&quot;);
 *   IloOplImportJava(&quot;my_application_classes.jar&quot;);
 * 
 *   IloOplCallJava(&quot;MyClass&quot;,&quot;performStuff&quot;,&quot;&quot;);
 * }
 * 
 * @globalFunction
 * @ilog.undocumented.jsFile
 * @type void
 * @param path The path to a directory or Java archive file (.jar) that contains classes to access.
*/" >
      <contexts>
                <context name="EVAL">        </context>
                <context name="POST">        </context>
                <context name="CPLEX">        </context>
                <context name="CP">        </context>
      </contexts>
    </function>
        <function name="IloOplCallJava"  isGlobal="true" isVar="false"  type="undefined" argument1="string" argument2="string" argument3="string" argument4="undefined" argument5="undefined"  javaDoc="/**
 * This function calls a Java method from a scripting block.
 *
 * &lt;p&gt;This method allows you to call Java objects and class methods from script statements and to translate their
 *     parameters and return types back and forth between Java and ILOG Script.&lt;/p&gt;
 * &lt;p&gt;&lt;b&gt;Translation of Input Parameters:&lt;/b&gt;&lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;Simple script types (Strings, Numbers, Booleans) are translated to their Java counterpart. For numbers, 
 *       the exact type is adapted to the Java method signature, and the number converted appropriately.&lt;/li&gt;
 *   &lt;li&gt;The ILOG Script null object is converted to Java null.&lt;/li&gt;       
 *   &lt;li&gt;The ILOG Script undefined object is converted to Java null.&lt;/li&gt;       
 *   &lt;li&gt;ILOG Script  native arrays (i.e. var v=new Array(), not OPL arrays) are converted to Java Object[] arrays,
 *       with all elements inside converted according to the conversion rules of input parameters. For simple type
 *       arrays, the array type is adapted to the Java method signature (i.e. if the method takes int[],
 *       the Object array is converted to an int[] array). &lt;/li&gt;       
 *   &lt;li&gt;ILOG Script OPL elements (arrays, sets, tuples, etc.) are converted to the Java API 
 *      &lt;code&gt;ilog.opl.IloOplElement&lt;/code&gt;. &lt;/li&gt;    
 *   &lt;li&gt;ILOG Script OPL models are converted to Java API &lt;code&gt;ilog.opl.IloOplModel&lt;/code&gt; instances. &lt;/li&gt;    
 *   &lt;li&gt;Custom Java objects returned from previous calls to Java are given back as the original
 *     object: If you call &lt;code&gt;&quot;var myObject=IloOplCallJava(...,&quot;method1&quot;,...); IloOplCallJava(...,&quot;method2&quot;,myObject);&quot;&lt;/code&gt;,
 *     then &lt;code&gt;method2&lt;/code&gt; will receive the Java object as it was returned by &lt;code&gt;method1&lt;/code&gt;. &lt;/li&gt;    
 *   &lt;li&gt;Other ILOG Script objects such as &lt;code&gt;IloObjective&lt;/code&gt;, &lt;code&gt;IloOplDataElements&lt;/code&gt;, etc. are not handled
 *      and are converted to a Java String containing their Script string representation. &lt;/li&gt;    
 *   &lt;li&gt;ILOG Script dates are not handled and are converted to a Java String &quot;UNKNOWN&quot;. &lt;/li&gt;       
  *&lt;/ul&gt;
  *&lt;p&gt;&lt;b&gt;Translation of Output Results:&lt;/b&gt;&lt;/p&gt;
  *&lt;ul&gt;
 *   &lt;li&gt;Simple Java types Strings, Numbers, Booleans are translated to their ILOG Script counterpart.&lt;/li&gt;
 *   &lt;li&gt;The Java null object is converted to the ILOG Script null object.&lt;/li&gt;       
 *   &lt;li&gt;Java Object[], int[], double[], boolean[] arrays are converted to ILOG Script arrays, 
 *      with elements converted according to the conversion rules of output results.&lt;/li&gt;       
 *   &lt;li&gt;Java &lt;code&gt;ilog.opl.IloOplDataSource&lt;/code&gt; objects are converted to ILOG Script data sources. This allows you to 
 *      use them in ILOG Script custom Java data sources.&lt;/li&gt;    
 *   &lt;li&gt;All other Java objects are returned as a special ILOG Script Java wrapper object that is suitable
 *      to be passed to other Java calls (see &quot;Translation of Input Parameters&quot; above). This
 *      wrapper object also supports a shortcut notation to call directly Java methods on 
 *      the underlying object as if they were ILOG Script methods: see &quot;Script Java Wrapper Object&quot; below.&lt;/li&gt; 
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;ILOG Script Java Wrapper Object:&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;Java objects returned from Java calls are wrapped in a special script object that allows you
 * to &apos;transport&apos; them to further Java classes (see above). As a convenience, they also support
 * calls to their Java methods as if they were ILOG Script methods.&lt;/p&gt;
 * &lt;p&gt;For example, if you obtain an object using:&lt;/p&gt;
 * &lt;pre class=&quot;ShortCode&quot;&gt;
 *    var myObject=IloOplCallJava(...);
 * &lt;/pre&gt;
 * &lt;p&gt;you can call its methods using either:&lt;/p&gt;
 * &lt;pre class=&quot;ShortCode&quot;&gt;
 *    var result=IloOplCallJava(myObject,&quot;myMethod&quot;,&quot;&quot;,...);
 * &lt;/pre&gt;
 * &lt;p&gt;or with the shorter and more natural:&lt;/p&gt;
 * &lt;pre class=&quot;ShortCode&quot;&gt;
 *    var result=myObject.myMethod(...);
 * &lt;/pre&gt;
 * &lt;p&gt;Note that the former notation does not allow you to specify a signature, so it applies
 *    only to non-overloaded methods (i.e. it does not work when the object has several methods
 *    with the same names but different signatures).&lt;/p&gt;
 * 
 * @example {Given a class such as:}
 *  package mypackage;
 *  import ilog.opl.*;
 *  public class MyClass {
 *    static public myStaticMethod(IloOplModel model,String param1) { ... }
 *     static public MyClass createInstance() { ... }
 *    public MyClass() { ... }
 *    public int performStuff(int param) { ... }
 *  }
 * 
 * @example {You can call it from a script statement by using:}
 * execute {
 *  IloOplImportJava(&quot;my_application_classes.jar&quot;);
 *
 *  // a simple call to a static method, giving parameters of different types:
 *  IloOplCallJava(&quot;mypackage.MyClass&quot;, // class name
 *                 &quot;myStaticMethod&quot;, // method name
 *                 &quot;&quot;, // signature omitted, no ambiguity
 *                 thisOplModel,&quot;p2&quot;); // parameters
 *                 
 *  // same call with full signature:
 *  IloOplCallJava(&quot;mypackage.MyClass&quot;, // class name
 *                 &quot;myStaticMethod&quot;, // method name
 *                 &quot;(Lilog/opl/IloOplModel;Ljava/lang/String;)V&quot;, // signature
 *                 thisOplModel,&quot;p2&quot;); // parameters
 *  
 *  // a call to a static method returning a Java object instance:
 *  var myObject=IloOplCallJava(&quot;mypackage.MyClass&quot;,
 *                              &quot;createInstance&quot;,&quot;&quot;);
 *                              
 *  // calling directly the constructor:
 *  var myObject=IloOplCallJava(&quot;mypackage.MyClass&quot;,
 *                              &quot;&lt;init&gt;&quot;,&quot;&quot;);
 *   
 *  // use the returned instance to call an instance method, giving some parameters, 
 *  // and that returns a simple int:
 *  var result=IloOplCallJava(myObject, // object
 *                          &quot;performStuff&quot;, // method
 *                          &quot;&quot;, // signature omitted
 *                          13); // parameter
 *                          
 *  // the exact same call using direct script call shortcut:
 *  var result=myObject.performStuff(13);                          
 *  }
 *
 * @globalFunction
 * @ilog.undocumented.jsFile
 * @param objectRefOrClassname a reference to the object on which we want to call an object method, 
 *  or the name of a class on which we want to call a static method.
 * @param methodName name of the method to call. Use &quot;&lt;init&gt;&quot; for a constructor.
 * @param methodSignature JNI signature of the method to call (see http://java.sun.com/docs/books/jni/html/fldmeth.html#26046), 
 *  or &quot;&quot; to call the first method that has the right name.
 * @param param1..N parameter(s) of the method (optional). They will be translated to the corresponding
 *  Java type on call (see above).
 * @return The return value of the Java, eventually converted to a script type (see above).
 * @type undefined
*/" >
      <contexts>
                <context name="EVAL">        </context>
                <context name="POST">        </context>
                <context name="CPLEX">        </context>
                <context name="CP">        </context>
      </contexts>
    </function>
        <function name="IloSearchPhase"  isGlobal="true" isVar="false"  javaDoc="/**
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 * @ignore
 */" >
      <contexts>
                <context name="EVAL">        </context>
                <context name="POST">        </context>
                <context name="CPLEX">        </context>
                <context name="CP">        </context>
      </contexts>
    </function>
        <function name="IloCP_eval"  isGlobal="true" isVar="false"  javaDoc="/**
* @ilog.undocumented.constructor
* @ilog.undocumented.jsFile
* @ignore
*/" >
      <contexts>
                <context name="EVAL">        </context>
                <context name="POST">        </context>
                <context name="CPLEX">        </context>
                <context name="CP">        </context>
      </contexts>
    </function>
        <function name="IloVarSelector"  isGlobal="true" isVar="false"  javaDoc="/**
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 * @ignore
 */" >
      <contexts>
                <context name="EVAL">        </context>
                <context name="POST">        </context>
                <context name="CPLEX">        </context>
                <context name="CP">        </context>
      </contexts>
    </function>
        <function name="IloValueSelector"  isGlobal="true" isVar="false"  javaDoc="/**
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 * @ignore
 */" >
      <contexts>
                <context name="EVAL">        </context>
                <context name="POST">        </context>
                <context name="CPLEX">        </context>
                <context name="CP">        </context>
      </contexts>
    </function>
        <function name="Opl"  isGlobal="true" isVar="false"  javaDoc="/**
* @class
* Using the &lt;b&gt;Opl&lt;/b&gt; namespace you can have access to OPL functions (such as &lt;code&gt;item()&lt;/code&gt;, &lt;code&gt;ord()&lt;/code&gt;, ...) in a scripting block.
* You can find more information on OPL modelling functions in the OPL document&lt;br /&gt;
* &lt;i&gt;Language Quick Reference&lt;/i&gt;&lt;/a&gt;.    
*
* @example
* int i = 10;
* execute {
*    var resu = Opl.abs( i );
* }
*
* @ilog.undocumented.constructor
* @ilog.undocumented.jsFile
*/" >
      <contexts>
                <context name="EVAL">        </context>
                <context name="POST">        </context>
                <context name="CPLEX">        </context>
                <context name="CP">        </context>
      </contexts>
    </function>
        <function name="IloPiecewiseFunctionExpr"  isGlobal="true" isVar="false"  javaDoc="/**
 * @class
 * @ignore
 * @ilog.undocumented.constructor
 * @ilog.undocumented.jsFile
 */" >
      <contexts>
                <context name="EVAL">        </context>
                <context name="POST">        </context>
                <context name="CPLEX">        </context>
                <context name="CP">        </context>
      </contexts>
    </function>
    <function name="lengthEval" type="float" argument1="dvar interval" argument2="pwlFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="lengthEval" type="float" argument1="dvar interval" argument2="pwlFunction" argument3="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startEval" type="float" argument1="dvar interval" argument2="pwlFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startEval" type="float" argument1="dvar interval" argument2="pwlFunction" argument3="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="length" type="int" argument1="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startAtStart" type="boolean" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startAtStart" type="boolean" argument1="dvar interval" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;=" type="boolean" argument1="float" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;=" type="boolean" argument1="string" argument2="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;=" type="boolean" argument1="cumulFunction" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;=" type="boolean" argument1="int" argument2="cumulFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&amp;&amp;" type="boolean" argument1="boolean" argument2="boolean" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&amp;&amp;" type="boolean" isVar="true" argument1="boolean" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prevc" type="int" argument1="{int}" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prevc" type="int" argument1="{int}" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prevc" type="float" argument1="{float}" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prevc" type="float" argument1="{float}" argument2="float" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prevc" type="string" argument1="{string}" argument2="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prevc" type="string" argument1="{string}" argument2="string" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prevc" type="&lt;*&gt;" argument1="{tuple-type}" argument2="&lt;*&gt;" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prevc" type="&lt;*&gt;" argument1="{tuple-type}" argument2="&lt;*&gt;" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="overlapLength" type="dexpr int" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="overlapLength" type="dexpr int" argument1="dvar interval" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="overlapLength" type="dexpr int" argument1="dvar interval" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="overlapLength" type="dexpr int" argument1="dvar interval" argument2="int" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="forbidEnd" type="boolean" argument1="dvar interval" argument2="stepFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorPROD" type="int" argument1="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorPROD" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorMOD" type="int" argument1="int" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="typeOfNext" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="typeOfNext" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="equivalent" type="boolean" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;.&lt;=" type="boolean" argument1="int" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><allow argument1="int" argument2="int" argument3="float" /><deny argument1="float" argument2="float" argument3="float" />        </context>
        <context name="CP"><allow argument1="int" argument2="int" argument3="float" /><deny argument1="float" argument2="float" argument3="float" />        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;.&lt;=" type="boolean" argument1="float" argument2="float" argument3="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><deny argument1="float" argument2="float" argument3="float" />        </context>
        <context name="CP"><deny argument1="float" argument2="float" argument3="float" />        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="allMinDistance" type="boolean" argument1="int[ ]" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="multipleSpan" type="boolean" argument1="arrayof_dvar interval" argument2="arrayof_dvar interval" isMultiDim="true" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="multipleSpan" type="boolean" argument1="arrayof_dvar interval" argument2="arrayof_dvar interval" argument3="int[]" argument4="int" isMultiDim="true" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="sizeOfNext" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="sizeOfNext" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startBeforeEnd" type="boolean" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startBeforeEnd" type="boolean" argument1="dvar interval" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;=.&gt;" type="boolean" argument1="int" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;=.&gt;" type="boolean" argument1="float" argument2="float" argument3="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="numberOfSegments" type="int" argument1="cumulFunction" >
      <contexts>
        <context name="EVAL"><denyname />        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP"><denyname />        </context>
        <context name="POST"><allow argument1="cumulFunction" /><denyname />        </context>
      </contexts>
    </function>
    <function name="numberOfSegments" type="int" argument1="stateFunction" >
      <contexts>
        <context name="EVAL"><denyname />        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP"><denyname />        </context>
        <context name="POST"><allow argument1="stateFunction" /><denyname />        </context>
      </contexts>
    </function>
    <function name="trunc" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endEval" type="float" argument1="dvar interval" argument2="pwlFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endEval" type="float" argument1="dvar interval" argument2="pwlFunction" argument3="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="asSet" type="{int}" argument1="range" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="stateFunctionValue" type="int" argument1="stateFunction" argument2="int" >
      <contexts>
        <context name="EVAL"><denyname />        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP"><denyname />        </context>
        <context name="POST"><allow argument1="stateFunction" argument2="int" /><denyname />        </context>
      </contexts>
    </function>
    <function name="log" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="implies" type="boolean" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="step" type="cumulFunction" argument1="int" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="ceil" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="maxl" type="int" isVar="true" argument1="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="maxl" type="float" isVar="true" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="segmentValue" type="int" argument1="cumulFunction" argument2="int" >
      <contexts>
        <context name="EVAL"><denyname />        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP"><denyname />        </context>
        <context name="POST"><allow argument1="cumulFunction" argument2="int" /><denyname />        </context>
      </contexts>
    </function>
    <function name="segmentValue" type="int" argument1="stateFunction" argument2="int" >
      <contexts>
        <context name="EVAL"><denyname />        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP"><denyname />        </context>
        <context name="POST"><allow argument1="stateFunction" argument2="int" /><denyname />        </context>
      </contexts>
    </function>
    <function name="intValue" type="int" argument1="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endOf" type="dexpr int" argument1="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endOf" type="dexpr int" argument1="dvar interval" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="stepAtEnd" type="cumulFunction" argument1="dvar interval" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="stepAtEnd" type="cumulFunction" argument1="dvar interval" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="first" type="int" argument1="{int}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="first" type="float" argument1="{float}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="first" type="string" argument1="{string}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="first" type="&lt;*&gt;" argument1="{tuple-type}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="first" type="boolean" argument1="dvar sequence" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="dual" type="float" argument1="constraint" >
      <contexts>
        <context name="EVAL"><denyname />        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP"><denyname />        </context>
        <context name="POST"><allow argument1="constraint" /><denyname />        </context>
      </contexts>
    </function>
    <function name="operatorSUM" type="int" argument1="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorSUM" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorSUM" type="cumulFunction" argument1="cumulFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="opposite" type="boolean" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startOf" type="dexpr int" argument1="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startOf" type="dexpr int" argument1="dvar interval" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;.&lt;" type="boolean" argument1="int" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><allow argument1="int" argument2="int" argument3="int" /><deny argument1="float" argument2="float" argument3="float" />        </context>
        <context name="CP"><allow argument1="int" argument2="int" argument3="int" /><deny argument1="float" argument2="float" argument3="float" />        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;.&lt;" type="boolean" argument1="float" argument2="float" argument3="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><deny argument1="float" argument2="float" argument3="float" />        </context>
        <context name="CP"><deny argument1="float" argument2="float" argument3="float" />        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="pulse" type="cumulFunction" argument1="dvar interval" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="pulse" type="cumulFunction" argument1="dvar interval" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="pulse" type="cumulFunction" argument1="int" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;.&gt;=" type="boolean" argument1="int" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;.&gt;=" type="boolean" argument1="float" argument2="float" argument3="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorSYMDIFF" type="{int}" argument1="{int}" argument2="{int}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorSYMDIFF" type="{float}" argument1="{float}" argument2="{float}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorSYMDIFF" type="{string}" argument1="{string}" argument2="{string}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorSYMDIFF" type="{tuple-type}" argument1="{tuple-type}" argument2="{tuple-type}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysConstant" type="boolean" argument1="stateFunction" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysConstant" type="boolean" argument1="stateFunction" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysConstant" type="boolean" argument1="stateFunction" argument2="int" argument3="int" argument4="int" argument5="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysConstant" type="boolean" argument1="stateFunction" argument2="dvar interval" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;=.&lt;" type="boolean" argument1="int" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><allow argument1="float" argument2="int" argument3="int" /><deny argument1="float" argument2="float" argument3="float" />        </context>
        <context name="CP"><allow argument1="float" argument2="int" argument3="int" /><deny argument1="float" argument2="float" argument3="float" />        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;=.&lt;" type="boolean" argument1="float" argument2="float" argument3="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><deny argument1="float" argument2="float" argument3="float" />        </context>
        <context name="CP"><deny argument1="float" argument2="float" argument3="float" />        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator==" type="boolean" argument1="int" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator==" type="boolean" argument1="float" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator==" type="boolean" argument1="string" argument2="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator==" type="boolean" argument1="&lt;*&gt;" argument2="&lt;*&gt;" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator=&gt;" type="boolean" argument1="boolean" argument2="boolean" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="heightAtEnd" type="int" argument1="dvar interval" argument2="cumulFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="heightAtEnd" type="int" argument1="dvar interval" argument2="cumulFunction" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorMIN" type="int" argument1="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorMIN" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="lengthOfPrev" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="lengthOfPrev" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="segmentStart" type="int" argument1="cumulFunction" argument2="int" >
      <contexts>
        <context name="EVAL"><denyname />        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP"><denyname />        </context>
        <context name="POST"><allow argument1="cumulFunction" argument2="int" /><denyname />        </context>
      </contexts>
    </function>
    <function name="segmentStart" type="int" argument1="stateFunction" argument2="int" >
      <contexts>
        <context name="EVAL"><denyname />        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP"><denyname />        </context>
        <context name="POST"><allow argument1="stateFunction" argument2="int" /><denyname />        </context>
      </contexts>
    </function>
    <function name="srand" type="int" argument1="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="impliesNot" type="boolean" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="cumulFunctionValue" type="int" argument1="cumulFunction" argument2="int" >
      <contexts>
        <context name="EVAL"><denyname />        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP"><denyname />        </context>
        <context name="POST"><allow argument1="cumulFunction" argument2="int" /><denyname />        </context>
      </contexts>
    </function>
    <function name="inverse" type="boolean" argument1="int[]" argument2="int[]" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startOfPrev" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startOfPrev" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorFORALL" type="boolean" argument1="boolean" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="span" type="boolean" argument1="dvar interval" argument2="arrayof_dvar interval" isMultiDim="true" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="sizeOf" type="dexpr int" argument1="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="sizeOf" type="dexpr int" argument1="dvar interval" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="forbidExtent" type="boolean" argument1="dvar interval" argument2="stepFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="minl" type="int" isVar="true" argument1="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="minl" type="float" isVar="true" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="reducedCost" type="float" argument1="dvar float" >
      <contexts>
        <context name="EVAL"><denyname />        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP"><denyname />        </context>
        <context name="POST"><allow argument1="dvar float" /><denyname />        </context>
      </contexts>
    </function>
    <function name="count" type="int" argument1="int[ ]" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;=" type="boolean" argument1="float" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;=" type="boolean" argument1="string" argument2="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;=" type="boolean" argument1="cumulFunction" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;=" type="boolean" argument1="int" argument2="cumulFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="sizeOfPrev" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="sizeOfPrev" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorMAX" type="int" argument1="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorMAX" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator||" type="boolean" argument1="boolean" argument2="boolean" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;=.&lt;=" type="boolean" argument1="int" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><allow argument1="int" argument2="int" argument3="int" />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;=.&lt;=" type="boolean" argument1="float" argument2="float" argument3="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;=.&lt;=" type="boolean" argument1="int" argument2="cumulFunction" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="before" type="boolean" argument1="dvar sequence" argument2="dvar interval" argument3="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="strong" type="boolean" argument1="int[ ]" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="strong" type="boolean" isVar="true" argument1="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorALL" type="*[range]" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorALL" type="*[range]" argument1="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorOR" type="boolean" argument1="boolean" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator^" type="float" argument1="float" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="distToInt" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endBeforeEnd" type="boolean" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endBeforeEnd" type="boolean" argument1="dvar interval" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="sameSequence" type="boolean" argument1="dvar sequence" argument2="dvar sequence" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="sameSequence" type="boolean" argument1="dvar sequence" argument2="dvar sequence" argument3="arrayof_dvar interval" argument4="arrayof_dvar interval" isMultiDim="true" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator!" type="boolean" argument1="boolean" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysIn" type="boolean" argument1="cumulFunction" argument2="dvar interval" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysIn" type="boolean" argument1="stateFunction" argument2="dvar interval" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysIn" type="boolean" argument1="cumulFunction" argument2="int" argument3="int" argument4="int" argument5="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysIn" type="boolean" argument1="stateFunction" argument2="int" argument3="int" argument4="int" argument5="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator?:" type="boolean" argument1="boolean" argument2="boolean" argument3="boolean" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator?:" type="int" argument1="boolean" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator?:" type="float" argument1="boolean" argument2="float" argument3="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator?:" type="string" argument1="boolean" argument2="string" argument3="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator?:" type="&lt;*&gt;" argument1="boolean" argument2="&lt;*&gt;" argument3="&lt;*&gt;" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator?:" type="{int}" argument1="boolean" argument2="{int}" argument3="{int}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator?:" type="{float}" argument1="boolean" argument2="{float}" argument3="{float}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator?:" type="{string}" argument1="boolean" argument2="{string}" argument3="{string}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator?:" type="{tuple-type}" argument1="boolean" argument2="{tuple-type}" argument3="{tuple-type}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator?:" type="cumulFunction" argument1="boolean" argument2="cumulFunction" argument3="cumulFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><deny argument1="boolean" argument2="cumulFunction" argument3="cumulFunction" />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator?:" type="pwlFunction" argument1="boolean" argument2="pwlFunction" argument3="pwlFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="allowedAssignments" type="boolean" isVar="true" argument1="{tuple-type}" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="heightAtStart" type="int" argument1="dvar interval" argument2="cumulFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="heightAtStart" type="int" argument1="dvar interval" argument2="cumulFunction" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="next" type="int" argument1="{int}" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="next" type="int" argument1="{int}" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="next" type="float" argument1="{float}" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="next" type="float" argument1="{float}" argument2="float" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="next" type="string" argument1="{string}" argument2="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="next" type="string" argument1="{string}" argument2="string" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="next" type="&lt;*&gt;" argument1="{tuple-type}" argument2="&lt;*&gt;" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="next" type="&lt;*&gt;" argument1="{tuple-type}" argument2="&lt;*&gt;" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startBeforeStart" type="boolean" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startBeforeStart" type="boolean" argument1="dvar interval" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator%" type="int" argument1="int" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endOfPrev" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endOfPrev" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="pow" type="float" argument1="float" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="pack" type="boolean" argument1="int[]" argument2="int[]" argument3="int[]" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="pack" type="boolean" argument1="int[]" argument2="int[]" argument3="int[]" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="last" type="int" argument1="{int}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="last" type="float" argument1="{float}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="last" type="string" argument1="{string}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="last" type="&lt;*&gt;" argument1="{tuple-type}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="last" type="boolean" argument1="dvar sequence" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="floor" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator*" type="int" argument1="int" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator*" type="float" argument1="float" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="nextc" type="int" argument1="{int}" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="nextc" type="int" argument1="{int}" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="nextc" type="float" argument1="{float}" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="nextc" type="float" argument1="{float}" argument2="float" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="nextc" type="string" argument1="{string}" argument2="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="nextc" type="string" argument1="{string}" argument2="string" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="nextc" type="&lt;*&gt;" argument1="{tuple-type}" argument2="&lt;*&gt;" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="nextc" type="&lt;*&gt;" argument1="{tuple-type}" argument2="&lt;*&gt;" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator+" type="int" argument1="int" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator+" type="float" argument1="float" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator+" type="cumulFunction" argument1="cumulFunction" argument2="cumulFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="element" type="float" argument1="*[range]" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="synchronize" type="boolean" argument1="dvar interval" argument2="arrayof_dvar interval" isMultiDim="true" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator-" type="int" argument1="int" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator-" type="float" argument1="float" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator-" type="int" argument1="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator-" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator-" type="cumulFunction" argument1="cumulFunction" argument2="cumulFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator-" type="cumulFunction" argument1="cumulFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorDIFF" type="{int}" argument1="{int}" argument2="{int}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorDIFF" type="{float}" argument1="{float}" argument2="{float}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorDIFF" type="{string}" argument1="{string}" argument2="{string}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorDIFF" type="{tuple-type}" argument1="{tuple-type}" argument2="{tuple-type}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorIN" type="boolean" argument1="int" argument2="{int}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorIN" type="boolean" argument1="int" argument2="range" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorIN" type="boolean" argument1="float" argument2="{float}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorIN" type="boolean" argument1="&lt;*&gt;" argument2="{tuple-type}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorIN" type="boolean" argument1="string" argument2="{string}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator/" type="float" argument1="float" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="noOverlap" type="boolean" argument1="dvar sequence" argument2="{tuple-type}" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="noOverlap" type="boolean" argument1="dvar sequence" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="noOverlap" type="boolean" argument1="dvar sequence" argument2="{tuple-type}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="noOverlap" type="boolean" argument1="arrayof_dvar interval" isMultiDim="true" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator!=" type="boolean" argument1="float" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><deny argument1="float" argument2="float" />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator!=" type="boolean" argument1="string" argument2="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator!=" type="boolean" argument1="&lt;*&gt;" argument2="&lt;*&gt;" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="sgn" type="int" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="presenceOf" type="boolean" argument1="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="stepAtStart" type="cumulFunction" argument1="dvar interval" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="stepAtStart" type="cumulFunction" argument1="dvar interval" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorAND" type="boolean" argument1="boolean" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="sizeEval" type="float" argument1="dvar interval" argument2="pwlFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="sizeEval" type="float" argument1="dvar interval" argument2="pwlFunction" argument3="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="matchAt" type="int" argument1="string" argument2="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="sqrt" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endOfNext" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endOfNext" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="ord" type="int" argument1="{int}" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="ord" type="int" argument1="{float}" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="ord" type="int" argument1="{string}" argument2="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="ord" type="int" argument1="{tuple-type}" argument2="&lt;*&gt;" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;" type="boolean" argument1="int" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><deny argument1="float" argument2="float" />        </context>
        <context name="CP"><allow argument1="int" argument2="int" /><allow argument1="int" argument2="float" /><allow argument1="float" argument2="int" /><deny argument1="float" argument2="float" />        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;" type="boolean" argument1="float" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><deny argument1="float" argument2="float" />        </context>
        <context name="CP"><deny argument1="float" argument2="float" />        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&lt;" type="boolean" argument1="string" argument2="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endAtStart" type="boolean" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endAtStart" type="boolean" argument1="dvar interval" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;=.&gt;=" type="boolean" argument1="int" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;=.&gt;=" type="boolean" argument1="float" argument2="float" argument3="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;=.&gt;=" type="boolean" argument1="int" argument2="cumulFunction" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alternative" type="boolean" argument1="dvar interval" argument2="arrayof_dvar interval" isMultiDim="true" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alternative" type="boolean" argument1="dvar interval" argument2="arrayof_dvar interval" argument3="int" isMultiDim="true" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;" type="boolean" argument1="int" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><deny argument1="float" argument2="float" />        </context>
        <context name="CP"><allow argument1="int" argument2="int" /><allow argument1="int" argument2="float" /><allow argument1="float" argument2="int" /><deny argument1="float" argument2="float" />        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;" type="boolean" argument1="float" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><deny argument1="float" argument2="float" />        </context>
        <context name="CP"><deny argument1="float" argument2="float" />        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;" type="boolean" argument1="string" argument2="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startOfNext" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startOfNext" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="sameCommonSubsequence" type="boolean" argument1="dvar sequence" argument2="dvar sequence" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="sameCommonSubsequence" type="boolean" argument1="dvar sequence" argument2="dvar sequence" argument3="arrayof_dvar interval" argument4="arrayof_dvar interval" isMultiDim="true" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="floatValue" type="float" argument1="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorDIV" type="int" argument1="int" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="slack" type="float" argument1="constraint" >
      <contexts>
        <context name="EVAL"><denyname />        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP"><denyname />        </context>
        <context name="POST"><allow argument1="constraint" /><denyname />        </context>
      </contexts>
    </function>
    <function name="staticLexFull" type="void" argument1="arrayof_float" argument2="arrayof_float" 
    		argument3="arrayof_int" argument4="arrayof_float" argument5="arrayof_float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">       </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="staticLex" type="void" argument1="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">       </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="staticLex" type="void" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">       </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="staticLex" type="void" argument1="int" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">      </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="staticLex" type="void" argument1="float" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">       </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="staticLex" type="void" argument1="int" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">       </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="staticLex" type="void" argument1="float" argument2="float" argument3="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">       </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="staticLex" type="void" argument1="int" argument2="int" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">       </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="staticLex" type="void" argument1="float" argument2="float" argument3="float" argument4="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">       </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="staticLex" type="void" argument1="int[ ]" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">       </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="staticLex" type="void" isVar="true" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endBeforeStart" type="boolean" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endBeforeStart" type="boolean" argument1="dvar interval" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startAtEnd" type="boolean" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="startAtEnd" type="boolean" argument1="dvar interval" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="lg" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="allDifferent" type="boolean" argument1="int[ ]" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="lengthOfNext" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="lengthOfNext" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysNoState" type="boolean" argument1="stateFunction" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysNoState" type="boolean" argument1="stateFunction" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="atoi" type="int" argument1="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="item" type="int" argument1="{int}" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="item" type="float" argument1="{float}" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="item" type="string" argument1="{string}" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="item" type="&lt;*&gt;" argument1="{tuple-type}" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="item" type="&lt;*&gt;" argument1="{tuple-type}" argument2="&lt;*&gt;" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="isomorphism" type="boolean" argument1="arrayof_dvar interval" argument2="arrayof_dvar interval" isMultiDim="true" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="isomorphism" type="boolean" argument1="arrayof_dvar interval" argument2="arrayof_dvar interval" argument3="int[]" argument4="int" isMultiDim="true" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="ln" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="abs" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="forbiddenAssignments" type="boolean" isVar="true" argument1="{tuple-type}" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorUNION" type="{int}" argument1="{int}" argument2="{int}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorUNION" type="{float}" argument1="{float}" argument2="{float}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorUNION" type="{string}" argument1="{string}" argument2="{string}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorUNION" type="{tuple-type}" argument1="{tuple-type}" argument2="{tuple-type}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorUNION" type="{int}" argument1="{int}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorUNION" type="{float}" argument1="{float}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorUNION" type="{string}" argument1="{string}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorUNION" type="{tuple-type}" argument1="{tuple-type}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="lengthOf" type="dexpr int" argument1="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="lengthOf" type="dexpr int" argument1="dvar interval" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="orWith" type="boolean" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorNOTIN" type="boolean" argument1="int" argument2="{int}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorNOTIN" type="boolean" argument1="int" argument2="range" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorNOTIN" type="boolean" argument1="float" argument2="{float}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorNOTIN" type="boolean" argument1="&lt;*&gt;" argument2="{tuple-type}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorNOTIN" type="boolean" argument1="string" argument2="{string}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;.&gt;" type="boolean" argument1="int" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operator&gt;.&gt;" type="boolean" argument1="float" argument2="float" argument3="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="standardDeviation" type="float" argument1="int[ ]" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="exp" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorINTER" type="{int}" argument1="{int}" argument2="{int}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorINTER" type="{float}" argument1="{float}" argument2="{float}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorINTER" type="{string}" argument1="{string}" argument2="{string}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorINTER" type="{tuple-type}" argument1="{tuple-type}" argument2="{tuple-type}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorINTER" type="{int}" argument1="{int}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorINTER" type="{float}" argument1="{float}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorINTER" type="{string}" argument1="{string}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="operatorINTER" type="{tuple-type}" argument1="{tuple-type}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="segmentEnd" type="int" argument1="cumulFunction" argument2="int" >
      <contexts>
        <context name="EVAL"><denyname />        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP"><denyname />        </context>
        <context name="POST"><allow argument1="cumulFunction" argument2="int" /><denyname />        </context>
      </contexts>
    </function>
    <function name="segmentEnd" type="int" argument1="stateFunction" argument2="int" >
      <contexts>
        <context name="EVAL"><denyname />        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP"><denyname />        </context>
        <context name="POST"><allow argument1="stateFunction" argument2="int" /><denyname />        </context>
      </contexts>
    </function>
    <function name="rand" type="int" argument1="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="rand" type="int"  >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><deny  />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endAtEnd" type="boolean" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="endAtEnd" type="boolean" argument1="dvar interval" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="ftoi" type="int" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prev" type="int" argument1="{int}" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prev" type="int" argument1="{int}" argument2="int" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prev" type="float" argument1="{float}" argument2="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prev" type="float" argument1="{float}" argument2="float" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prev" type="string" argument1="{string}" argument2="string" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prev" type="string" argument1="{string}" argument2="string" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prev" type="&lt;*&gt;" argument1="{tuple-type}" argument2="&lt;*&gt;" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prev" type="&lt;*&gt;" argument1="{tuple-type}" argument2="&lt;*&gt;" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="prev" type="boolean" argument1="dvar sequence" argument2="dvar interval" argument3="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="frac" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysEqual" type="boolean" argument1="cumulFunction" argument2="int" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysEqual" type="boolean" argument1="stateFunction" argument2="int" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysEqual" type="boolean" argument1="cumulFunction" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysEqual" type="boolean" argument1="stateFunction" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysEqual" type="boolean" argument1="stateFunction" argument2="int" argument3="int" argument4="int" argument5="int" argument6="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="alwaysEqual" type="boolean" argument1="stateFunction" argument2="dvar interval" argument3="int" argument4="int" argument5="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="forbidStart" type="boolean" argument1="dvar interval" argument2="stepFunction" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="round" type="float" argument1="float" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="card" type="int" argument1="{tuple-type}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="card" type="int" argument1="range" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="card" type="int" argument1="{int}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="card" type="int" argument1="{float}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="card" type="int" argument1="{string}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="keySet" type="{tuple-type}" argument1="{tuple-type}" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="lex" type="boolean" argument1="int[ ]" argument2="int[ ]" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="append" type="int[]" isVar="true" argument1="int" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="append" type="int[]" isVar="true" argument1="int[ ]" argument2="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="append" type="int[]" isVar="true" argument1="int[ ]" argument2="int[ ]" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="append" type="dvar interval[ ]" isVar="true" argument1="arrayof_dvar interval" argument2="arrayof_dvar interval" isMultiDim="true" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="append" type="dvar interval[ ]" isVar="true" argument1="dvar interval" argument2="dvar interval" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="append" type="dvar interval[ ]" isVar="true" argument1="arrayof_dvar interval" argument2="dvar interval" isMultiDim="true" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="itoa" type="string" argument1="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX">        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="typeOfPrev" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
    <function name="typeOfPrev" type="int" argument1="dvar sequence" argument2="dvar interval" argument3="int" argument4="int" >
      <contexts>
        <context name="EVAL">        </context>
        <context name="CPLEX"><denyname />        </context>
        <context name="CP">        </context>
        <context name="POST">        </context>
      </contexts>
    </function>
  </functions>
</ast>
